L 1 "usbhw.c"
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usbhw.c
N * Purpose: USB Hardware Layer Module for NXP's LPC17xx MCU
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *----------------------------------------------------------------------------
N * History:
N *          V1.20 Added USB_ClearEPBuf
N *          V1.00 Initial Version
N *----------------------------------------------------------------------------*/
N
N#include "LPC17xx.h"                    // Device header
L 1 "LPC17xx.h" 1
N/******************************************************************************
N * @file:    LPC17xx.h
N * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Header File for 
N *           NXP LPC17xx Device Series 
N * @version: V1.10
N * @date:    24. September 2010
N *----------------------------------------------------------------------------
N *
N * @note
N * Copyright (C) 2010 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M3 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __LPC17xx_H__
N#define __LPC17xx_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N */
N
N/** @addtogroup LPC17xx_System
N * @{
N */
N
N/** @brief IRQ interrupt source definition */
Ntypedef enum IRQn
N{
N/******  Cortex-M3 Processor Exceptions Numbers ***************************************************/
N  NonMaskableInt_IRQn           = -14,      /*!< 2 Non Maskable Interrupt                         */
N  MemoryManagement_IRQn         = -12,      /*!< 4 Cortex-M3 Memory Management Interrupt          */
N  BusFault_IRQn                 = -11,      /*!< 5 Cortex-M3 Bus Fault Interrupt                  */
N  UsageFault_IRQn               = -10,      /*!< 6 Cortex-M3 Usage Fault Interrupt                */
N  SVCall_IRQn                   = -5,       /*!< 11 Cortex-M3 SV Call Interrupt                   */
N  DebugMonitor_IRQn             = -4,       /*!< 12 Cortex-M3 Debug Monitor Interrupt             */
N  PendSV_IRQn                   = -2,       /*!< 14 Cortex-M3 Pend SV Interrupt                   */
N  SysTick_IRQn                  = -1,       /*!< 15 Cortex-M3 System Tick Interrupt               */
N
N/******  LPC17xx Specific Interrupt Numbers *******************************************************/
N  WDT_IRQn                      = 0,        /*!< Watchdog Timer Interrupt                         */
N  TIMER0_IRQn                   = 1,        /*!< Timer0 Interrupt                                 */
N  TIMER1_IRQn                   = 2,        /*!< Timer1 Interrupt                                 */
N  TIMER2_IRQn                   = 3,        /*!< Timer2 Interrupt                                 */
N  TIMER3_IRQn                   = 4,        /*!< Timer3 Interrupt                                 */
N  UART0_IRQn                    = 5,        /*!< UART0 Interrupt                                  */
N  UART1_IRQn                    = 6,        /*!< UART1 Interrupt                                  */
N  UART2_IRQn                    = 7,        /*!< UART2 Interrupt                                  */
N  UART3_IRQn                    = 8,        /*!< UART3 Interrupt                                  */
N  PWM1_IRQn                     = 9,        /*!< PWM1 Interrupt                                   */
N  I2C0_IRQn                     = 10,       /*!< I2C0 Interrupt                                   */
N  I2C1_IRQn                     = 11,       /*!< I2C1 Interrupt                                   */
N  I2C2_IRQn                     = 12,       /*!< I2C2 Interrupt                                   */
N  SPI_IRQn                      = 13,       /*!< SPI Interrupt                                    */
N  SSP0_IRQn                     = 14,       /*!< SSP0 Interrupt                                   */
N  SSP1_IRQn                     = 15,       /*!< SSP1 Interrupt                                   */
N  PLL0_IRQn                     = 16,       /*!< PLL0 Lock (Main PLL) Interrupt                   */
N  RTC_IRQn                      = 17,       /*!< Real Time Clock Interrupt                        */
N  EINT0_IRQn                    = 18,       /*!< External Interrupt 0 Interrupt                   */
N  EINT1_IRQn                    = 19,       /*!< External Interrupt 1 Interrupt                   */
N  EINT2_IRQn                    = 20,       /*!< External Interrupt 2 Interrupt                   */
N  EINT3_IRQn                    = 21,       /*!< External Interrupt 3 Interrupt                   */
N  ADC_IRQn                      = 22,       /*!< A/D Converter Interrupt                          */
N  BOD_IRQn                      = 23,       /*!< Brown-Out Detect Interrupt                       */
N  USB_IRQn                      = 24,       /*!< USB Interrupt                                    */
N  CAN_IRQn                      = 25,       /*!< CAN Interrupt                                    */
N  DMA_IRQn                      = 26,       /*!< General Purpose DMA Interrupt                    */
N  I2S_IRQn                      = 27,       /*!< I2S Interrupt                                    */
N  ENET_IRQn                     = 28,       /*!< Ethernet Interrupt                               */
N  RIT_IRQn                      = 29,       /*!< Repetitive Interrupt Timer Interrupt             */
N  MCPWM_IRQn                    = 30,       /*!< Motor Control PWM Interrupt                      */
N  QEI_IRQn                      = 31,       /*!< Quadrature Encoder Interface Interrupt           */
N  PLL1_IRQn                     = 32,       /*!< PLL1 Lock (USB PLL) Interrupt                    */
N  USBActivity_IRQn              = 33,       /*!< USB Activity Interrupt(For wakeup only)          */
N  CANActivity_IRQn              = 34        /*!< CAN Activity Interrupt(For wakeup only)          */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M3 Processor and Core Peripherals */
N#define __MPU_PRESENT             1         /*!< MPU present or not                               */
N#define __NVIC_PRIO_BITS          5         /*!< Number of Bits used for Priority Levels          */
N#define __Vendor_SysTickConfig    0         /*!< Set to 1 if different SysTick Config is used     */
N
N
N#include "core_cm3.h"                       /* Cortex-M3 processor and core peripherals           */
L 1 "core_cm3.h" 1
N/******************************************************************************
N * @file:    core_cm3.h
N * @purpose: CMSIS Cortex-M3 Core Peripheral Access Layer Header File
N * @version: V1.20
N * @date:    22. May 2009
N *----------------------------------------------------------------------------
N *
N * Copyright (C) 2009 ARM Limited. All rights reserved.
N *
N * ARM Limited (ARM) is supplying this software for use with Cortex-Mx 
N * processor based microcontrollers.  This file can be freely distributed 
N * within development tools that are supporting such ARM based processors. 
N *
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CM3_CORE_H__
N#define __CM3_CORE_H__
N
N#ifdef __cplusplus
S extern "C" {
N#endif 
N
N#define __CM3_CMSIS_VERSION_MAIN  (0x01)                                                       /*!< [31:16] CMSIS HAL main version */
N#define __CM3_CMSIS_VERSION_SUB   (0x20)                                                       /*!< [15:0]  CMSIS HAL sub version  */
N#define __CM3_CMSIS_VERSION       ((__CM3_CMSIS_VERSION_MAIN << 16) | __CM3_CMSIS_VERSION_SUB) /*!< CMSIS HAL version number       */
N
N#define __CORTEX_M                (0x03)                                                       /*!< Cortex core                    */
N
N/**
N *  Lint configuration \n
N *  ----------------------- \n
N *
N *  The following Lint messages will be suppressed and not shown: \n
N *  \n
N *    --- Error 10: --- \n
N *    register uint32_t __regBasePri         __asm("basepri"); \n
N *    Error 10: Expecting ';' \n
N *     \n
N *    --- Error 530: --- \n
N *    return(__regBasePri); \n
N *    Warning 530: Symbol '__regBasePri' (line 264) not initialized \n
N *     \n
N *    --- Error 550: --- \n
N *      __regBasePri = (basePri & 0x1ff); \n
N *    } \n
N *    Warning 550: Symbol '__regBasePri' (line 271) not accessed \n
N *     \n
N *    --- Error 754: --- \n
N *    uint32_t RESERVED0[24]; \n
N *    Info 754: local structure member '<some, not used in the HAL>' (line 109, file ./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 750: --- \n
N *    #define __CM3_CORE_H__ \n
N *    Info 750: local macro '__CM3_CORE_H__' (line 43, file./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 528: --- \n
N *    static __INLINE void NVIC_DisableIRQ(uint32_t IRQn) \n
N *    Warning 528: Symbol 'NVIC_DisableIRQ(unsigned int)' (line 419, file ./cm3_core.h) not referenced \n
N *     \n
N *    --- Error 751: --- \n
N *    } InterruptType_Type; \n
N *    Info 751: local typedef 'InterruptType_Type' (line 170, file ./cm3_core.h) not referenced \n
N * \n
N * \n
N *    Note:  To re-enable a Message, insert a space before 'lint' * \n
N *
N */
N
N/*lint -save */
N/*lint -e10  */
N/*lint -e530 */
N/*lint -e550 */
N/*lint -e754 */
N/*lint -e750 */
N/*lint -e528 */
N/*lint -e751 */
N
N
N#include <stdint.h>                           /* Include standard types */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 86 "core_cm3.h" 2
N
N#if defined (__ICCARM__)
X#if 0L
S  #include <intrinsics.h>                     /* IAR Intrinsics   */
N#endif
N
N
N#ifndef __NVIC_PRIO_BITS
S  #define __NVIC_PRIO_BITS    4               /*!< standard definition for NVIC Priority Bits */
N#endif
N
N
N
N
N/**
N * IO definitions
N *
N * define access restrictions to peripheral registers
N */
N
N#ifdef __cplusplus
S#define     __I     volatile                  /*!< defines 'read only' permissions      */
N#else
N#define     __I     volatile const            /*!< defines 'read only' permissions      */
N#endif
N#define     __O     volatile                  /*!< defines 'write only' permissions     */
N#define     __IO    volatile                  /*!< defines 'read / write' permissions   */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N ******************************************************************************/
N
N
N/* System Reset */
N#define NVIC_VECTRESET              0         /*!< Vector Reset Bit             */
N#define NVIC_SYSRESETREQ            2         /*!< System Reset Request         */
N#define NVIC_AIRCR_VECTKEY    (0x5FA << 16)   /*!< AIRCR Key for write access   */
N#define NVIC_AIRCR_ENDIANESS        15        /*!< Endianess                    */
N
N/* Core Debug */
N#define CoreDebug_DEMCR_TRCENA (1 << 24)      /*!< DEMCR TRCENA enable          */
N#define ITM_TCR_ITMENA              1         /*!< ITM enable                   */
N
N
N
N
N/* memory mapping struct for Nested Vectored Interrupt Controller (NVIC) */
Ntypedef struct
N{
N  __IO uint32_t ISER[8];                      /*!< Interrupt Set Enable Register            */
X  volatile uint32_t ISER[8];                       
N       uint32_t RESERVED0[24];
N  __IO uint32_t ICER[8];                      /*!< Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[8];                       
N       uint32_t RSERVED1[24];
N  __IO uint32_t ISPR[8];                      /*!< Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[8];                       
N       uint32_t RESERVED2[24];
N  __IO uint32_t ICPR[8];                      /*!< Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[8];                       
N       uint32_t RESERVED3[24];
N  __IO uint32_t IABR[8];                      /*!< Interrupt Active bit Register            */
X  volatile uint32_t IABR[8];                       
N       uint32_t RESERVED4[56];
N  __IO uint8_t  IP[240];                      /*!< Interrupt Priority Register, 8Bit wide   */
X  volatile uint8_t  IP[240];                       
N       uint32_t RESERVED5[644];
N  __O  uint32_t STIR;                         /*!< Software Trigger Interrupt Register      */
X  volatile  uint32_t STIR;                          
N}  NVIC_Type;
N
N
N/* memory mapping struct for System Control Block */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                        /*!< CPU ID Base Register                                     */
X  volatile const  uint32_t CPUID;                         
N  __IO uint32_t ICSR;                         /*!< Interrupt Control State Register                         */
X  volatile uint32_t ICSR;                          
N  __IO uint32_t VTOR;                         /*!< Vector Table Offset Register                             */
X  volatile uint32_t VTOR;                          
N  __IO uint32_t AIRCR;                        /*!< Application Interrupt / Reset Control Register           */
X  volatile uint32_t AIRCR;                         
N  __IO uint32_t SCR;                          /*!< System Control Register                                  */
X  volatile uint32_t SCR;                           
N  __IO uint32_t CCR;                          /*!< Configuration Control Register                           */
X  volatile uint32_t CCR;                           
N  __IO uint8_t  SHP[12];                      /*!< System Handlers Priority Registers (4-7, 8-11, 12-15)    */
X  volatile uint8_t  SHP[12];                       
N  __IO uint32_t SHCSR;                        /*!< System Handler Control and State Register                */
X  volatile uint32_t SHCSR;                         
N  __IO uint32_t CFSR;                         /*!< Configurable Fault Status Register                       */
X  volatile uint32_t CFSR;                          
N  __IO uint32_t HFSR;                         /*!< Hard Fault Status Register                               */
X  volatile uint32_t HFSR;                          
N  __IO uint32_t DFSR;                         /*!< Debug Fault Status Register                              */
X  volatile uint32_t DFSR;                          
N  __IO uint32_t MMFAR;                        /*!< Mem Manage Address Register                              */
X  volatile uint32_t MMFAR;                         
N  __IO uint32_t BFAR;                         /*!< Bus Fault Address Register                               */
X  volatile uint32_t BFAR;                          
N  __IO uint32_t AFSR;                         /*!< Auxiliary Fault Status Register                          */
X  volatile uint32_t AFSR;                          
N  __I  uint32_t PFR[2];                       /*!< Processor Feature Register                               */
X  volatile const  uint32_t PFR[2];                        
N  __I  uint32_t DFR;                          /*!< Debug Feature Register                                   */
X  volatile const  uint32_t DFR;                           
N  __I  uint32_t ADR;                          /*!< Auxiliary Feature Register                               */
X  volatile const  uint32_t ADR;                           
N  __I  uint32_t MMFR[4];                      /*!< Memory Model Feature Register                            */
X  volatile const  uint32_t MMFR[4];                       
N  __I  uint32_t ISAR[5];                      /*!< ISA Feature Register                                     */
X  volatile const  uint32_t ISAR[5];                       
N} SCB_Type;
N
N
N/* memory mapping struct for SysTick */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                         /*!< SysTick Control and Status Register */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t LOAD;                         /*!< SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                          
N  __IO uint32_t VAL;                          /*!< SysTick Current Value Register      */
X  volatile uint32_t VAL;                           
N  __I  uint32_t CALIB;                        /*!< SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                         
N} SysTick_Type;
N
N
N/* memory mapping structur for ITM */
Ntypedef struct
N{
N  __O  union  
X  volatile  union  
N  {
N    __O  uint8_t    u8;                       /*!< ITM Stimulus Port 8-bit               */
X    volatile  uint8_t    u8;                        
N    __O  uint16_t   u16;                      /*!< ITM Stimulus Port 16-bit              */
X    volatile  uint16_t   u16;                       
N    __O  uint32_t   u32;                      /*!< ITM Stimulus Port 32-bit              */
X    volatile  uint32_t   u32;                       
N  }  PORT [32];                               /*!< ITM Stimulus Port Registers           */
N       uint32_t RESERVED0[864];
N  __IO uint32_t TER;                          /*!< ITM Trace Enable Register             */
X  volatile uint32_t TER;                           
N       uint32_t RESERVED1[15];
N  __IO uint32_t TPR;                          /*!< ITM Trace Privilege Register          */
X  volatile uint32_t TPR;                           
N       uint32_t RESERVED2[15];
N  __IO uint32_t TCR;                          /*!< ITM Trace Control Register            */
X  volatile uint32_t TCR;                           
N       uint32_t RESERVED3[29];
N  __IO uint32_t IWR;                          /*!< ITM Integration Write Register        */
X  volatile uint32_t IWR;                           
N  __IO uint32_t IRR;                          /*!< ITM Integration Read Register         */
X  volatile uint32_t IRR;                           
N  __IO uint32_t IMCR;                         /*!< ITM Integration Mode Control Register */
X  volatile uint32_t IMCR;                          
N       uint32_t RESERVED4[43];
N  __IO uint32_t LAR;                          /*!< ITM Lock Access Register              */
X  volatile uint32_t LAR;                           
N  __IO uint32_t LSR;                          /*!< ITM Lock Status Register              */
X  volatile uint32_t LSR;                           
N       uint32_t RESERVED5[6];
N  __I  uint32_t PID4;                         /*!< ITM Product ID Registers              */
X  volatile const  uint32_t PID4;                          
N  __I  uint32_t PID5;
X  volatile const  uint32_t PID5;
N  __I  uint32_t PID6;
X  volatile const  uint32_t PID6;
N  __I  uint32_t PID7;
X  volatile const  uint32_t PID7;
N  __I  uint32_t PID0;
X  volatile const  uint32_t PID0;
N  __I  uint32_t PID1;
X  volatile const  uint32_t PID1;
N  __I  uint32_t PID2;
X  volatile const  uint32_t PID2;
N  __I  uint32_t PID3;
X  volatile const  uint32_t PID3;
N  __I  uint32_t CID0;
X  volatile const  uint32_t CID0;
N  __I  uint32_t CID1;
X  volatile const  uint32_t CID1;
N  __I  uint32_t CID2;
X  volatile const  uint32_t CID2;
N  __I  uint32_t CID3;
X  volatile const  uint32_t CID3;
N} ITM_Type;
N
N
N/* memory mapped struct for Interrupt Type */
Ntypedef struct
N{
N       uint32_t RESERVED0;
N  __I  uint32_t ICTR;                         /*!< Interrupt Control Type Register  */
X  volatile const  uint32_t ICTR;                          
N#if ((defined __CM3_REV) && (__CM3_REV >= 0x200))
X#if ((0L) && (__CM3_REV >= 0x200))
S  __IO uint32_t ACTLR;                        /*!< Auxiliary Control Register       */
N#else
N       uint32_t RESERVED1;
N#endif
N} InterruptType_Type;
N
N
N/* Memory Protection Unit */
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
Ntypedef struct
N{
N  __I  uint32_t TYPE;                         /*!< MPU Type Register                               */
X  volatile const  uint32_t TYPE;                          
N  __IO uint32_t CTRL;                         /*!< MPU Control Register                            */
X  volatile uint32_t CTRL;                          
N  __IO uint32_t RNR;                          /*!< MPU Region RNRber Register                      */
X  volatile uint32_t RNR;                           
N  __IO uint32_t RBAR;                         /*!< MPU Region Base Address Register                */
X  volatile uint32_t RBAR;                          
N  __IO uint32_t RASR;                         /*!< MPU Region Attribute and Size Register          */
X  volatile uint32_t RASR;                          
N  __IO uint32_t RBAR_A1;                      /*!< MPU Alias 1 Region Base Address Register        */
X  volatile uint32_t RBAR_A1;                       
N  __IO uint32_t RASR_A1;                      /*!< MPU Alias 1 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A1;                       
N  __IO uint32_t RBAR_A2;                      /*!< MPU Alias 2 Region Base Address Register        */
X  volatile uint32_t RBAR_A2;                       
N  __IO uint32_t RASR_A2;                      /*!< MPU Alias 2 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A2;                       
N  __IO uint32_t RBAR_A3;                      /*!< MPU Alias 3 Region Base Address Register        */
X  volatile uint32_t RBAR_A3;                       
N  __IO uint32_t RASR_A3;                      /*!< MPU Alias 3 Region Attribute and Size Register  */
X  volatile uint32_t RASR_A3;                       
N} MPU_Type;
N#endif
N
N
N/* Core Debug Register */
Ntypedef struct
N{
N  __IO uint32_t DHCSR;                        /*!< Debug Halting Control and Status Register       */
X  volatile uint32_t DHCSR;                         
N  __O  uint32_t DCRSR;                        /*!< Debug Core Register Selector Register           */
X  volatile  uint32_t DCRSR;                         
N  __IO uint32_t DCRDR;                        /*!< Debug Core Register Data Register               */
X  volatile uint32_t DCRDR;                         
N  __IO uint32_t DEMCR;                        /*!< Debug Exception and Monitor Control Register    */
X  volatile uint32_t DEMCR;                         
N} CoreDebug_Type;
N
N
N/* Memory mapping of Cortex-M3 Hardware */
N#define SCS_BASE            (0xE000E000)                              /*!< System Control Space Base Address    */
N#define ITM_BASE            (0xE0000000)                              /*!< ITM Base Address                     */
N#define CoreDebug_BASE      (0xE000EDF0)                              /*!< Core Debug Base Address              */
N#define SysTick_BASE        (SCS_BASE +  0x0010)                      /*!< SysTick Base Address                 */
N#define NVIC_BASE           (SCS_BASE +  0x0100)                      /*!< NVIC Base Address                    */
N#define SCB_BASE            (SCS_BASE +  0x0D00)                      /*!< System Control Block Base Address    */
N
N#define InterruptType       ((InterruptType_Type *) SCS_BASE)         /*!< Interrupt Type Register              */
N#define SCB                 ((SCB_Type *)           SCB_BASE)         /*!< SCB configuration struct             */
N#define SysTick             ((SysTick_Type *)       SysTick_BASE)     /*!< SysTick configuration struct         */
N#define NVIC                ((NVIC_Type *)          NVIC_BASE)        /*!< NVIC configuration struct            */
N#define ITM                 ((ITM_Type *)           ITM_BASE)         /*!< ITM configuration struct             */
N#define CoreDebug           ((CoreDebug_Type *)     CoreDebug_BASE)   /*!< Core Debug configuration struct      */
N
N#if defined (__MPU_PRESENT) && (__MPU_PRESENT == 1)
X#if 1L && (1 == 1)
N  #define MPU_BASE          (SCS_BASE +  0x0D90)                      /*!< Memory Protection Unit               */
N  #define MPU               ((MPU_Type*)            MPU_BASE)         /*!< Memory Protection Unit               */
N#endif
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N ******************************************************************************/
N
N
N#if defined ( __CC_ARM   )
X#if 1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N
N#elif defined ( __ICCARM__ )
S  #define __ASM           __asm                                       /*!< asm keyword for IAR Compiler           */
S  #define __INLINE        inline                                      /*!< inline keyword for IAR Compiler. Only avaiable in High optimization mode! */
S
S#elif defined   (  __GNUC__  )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S
S#elif defined   (  __TASKING__  )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler       */
S
N#endif
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N
N#if defined ( __CC_ARM   ) /*------------------RealView Compiler -----------------*/
X#if 1L  
N/* ARM armcc specific functions */
N
N#define __enable_fault_irq                __enable_fiq
N#define __disable_fault_irq               __disable_fiq
N
N#define __NOP                             __nop
N#define __WFI                             __wfi
N#define __WFE                             __wfe
N#define __SEV                             __sev
N#define __ISB()                           __isb(0)
N#define __DSB()                           __dsb(0)
N#define __DMB()                           __dmb(0)
N#define __REV                             __rev
N#define __RBIT                            __rbit
N#define __LDREXB(ptr)                     ((unsigned char ) __ldrex(ptr))
N#define __LDREXH(ptr)                     ((unsigned short) __ldrex(ptr))
N#define __LDREXW(ptr)                     ((unsigned int  ) __ldrex(ptr))
N#define __STREXB(value, ptr)              __strex(value, ptr)
N#define __STREXH(value, ptr)              __strex(value, ptr)
N#define __STREXW(value, ptr)              __strex(value, ptr)
N
N
N/* intrinsic unsigned long long __ldrexd(volatile void *ptr) */
N/* intrinsic int __strexd(unsigned long long val, volatile void *ptr) */
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N
N/**
N * @brief  Return the Process Stack Pointer
N *
N * @param  none
N * @return uint32_t ProcessStackPointer
N *
N * Return the actual process stack pointer
N */
Nextern uint32_t __get_PSP(void);
N
N/**
N * @brief  Set the Process Stack Pointer
N *
N * @param  uint32_t Process Stack Pointer
N * @return none
N *
N * Assign the value ProcessStackPointer to the MSP 
N * (process stack pointer) Cortex processor register
N */
Nextern void __set_PSP(uint32_t topOfProcStack);
N
N/**
N * @brief  Return the Main Stack Pointer
N *
N * @param  none
N * @return uint32_t Main Stack Pointer
N *
N * Return the current value of the MSP (main stack pointer)
N * Cortex processor register
N */
Nextern uint32_t __get_MSP(void);
N
N/**
N * @brief  Set the Main Stack Pointer
N *
N * @param  uint32_t Main Stack Pointer
N * @return none
N *
N * Assign the value mainStackPointer to the MSP 
N * (main stack pointer) Cortex processor register
N */
Nextern void __set_MSP(uint32_t topOfMainStack);
N
N/**
N * @brief  Reverse byte order in unsigned short value
N *
N * @param  uint16_t value to reverse
N * @return uint32_t reversed value
N *
N * Reverse byte order in unsigned short value
N */
Nextern uint32_t __REV16(uint16_t value);
N
N/*
N * @brief  Reverse byte order in signed short value with sign extension to integer
N *
N * @param  int16_t value to reverse
N * @return int32_t reversed value
N *
N * Reverse byte order in signed short value with sign extension to integer
N */
Nextern int32_t __REVSH(int16_t value);
N
N
N#if (__ARMCC_VERSION < 400000)
X#if (5060750 < 400000)
S
S/**
S * @brief  Remove the exclusive lock created by ldrex
S *
S * @param  none
S * @return none
S *
S * Removes the exclusive lock which is created by ldrex.
S */
Sextern void __CLREX(void);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @param  none
S * @return uint32_t BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  uint32_t BasePriority
S * @return none
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @param  none
S * @return uint32_t PriMask
S *
S * Return the state of the priority mask bit from the priority mask
S * register
S */
Sextern uint32_t __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  uint32_t PriMask
S * @return none
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @param  none
S * @return uint32_t FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  uint32_t faultMask value
S * @return none
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S * 
S * @param  none
S * @return uint32_t Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  uint32_t Control value
S * @return none
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
N#else  /* (__ARMCC_VERSION >= 400000)  */
N
N
N/**
N * @brief  Remove the exclusive lock created by ldrex
N *
N * @param  none
N * @return none
N *
N * Removes the exclusive lock which is created by ldrex.
N */
N#define __CLREX                           __clrex
N
N/**
N * @brief  Return the Base Priority value
N *
N * @param  none
N * @return uint32_t BasePriority
N *
N * Return the content of the base priority register
N */
Nstatic __INLINE uint32_t  __get_BASEPRI(void)
Xstatic __inline uint32_t  __get_BASEPRI(void)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  return(__regBasePri);
N}
N
N/**
N * @brief  Set the Base Priority value
N *
N * @param  uint32_t BasePriority
N * @return none
N *
N * Set the base priority register
N */
Nstatic __INLINE void __set_BASEPRI(uint32_t basePri)
Xstatic __inline void __set_BASEPRI(uint32_t basePri)
N{
N  register uint32_t __regBasePri         __ASM("basepri");
X  register uint32_t __regBasePri         __asm("basepri");
N  __regBasePri = (basePri & 0x1ff);
N}
N
N/**
N * @brief  Return the Priority Mask value
N *
N * @param  none
N * @return uint32_t PriMask
N *
N * Return the state of the priority mask bit from the priority mask
N * register
N */
Nstatic __INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N/**
N * @brief  Set the Priority Mask value
N *
N * @param  uint32_t PriMask
N * @return none
N *
N * Set the priority mask bit in the priority mask register
N */
Nstatic __INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N/**
N * @brief  Return the Fault Mask value
N *
N * @param  none
N * @return uint32_t FaultMask
N *
N * Return the content of the fault mask register
N */
Nstatic __INLINE uint32_t __get_FAULTMASK(void)
Xstatic __inline uint32_t __get_FAULTMASK(void)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  return(__regFaultMask);
N}
N
N/**
N * @brief  Set the Fault Mask value
N *
N * @param  uint32_t faultMask value
N * @return none
N *
N * Set the fault mask register
N */
Nstatic __INLINE void __set_FAULTMASK(uint32_t faultMask)
Xstatic __inline void __set_FAULTMASK(uint32_t faultMask)
N{
N  register uint32_t __regFaultMask       __ASM("faultmask");
X  register uint32_t __regFaultMask       __asm("faultmask");
N  __regFaultMask = (faultMask & 1);
N}
N
N/**
N * @brief  Return the Control Register value
N * 
N * @param  none
N * @return uint32_t Control value
N *
N * Return the content of the control register
N */
Nstatic __INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N/**
N * @brief  Set the Control Register value
N *
N * @param  uint32_t Control value
N * @return none
N *
N * Set the control register
N */
Nstatic __INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N#endif /* __ARMCC_VERSION  */ 
N
N
N
N#elif (defined (__ICCARM__)) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#define __enable_irq                              __enable_interrupt        /*!< global Interrupt enable */
S#define __disable_irq                             __disable_interrupt       /*!< global Interrupt disable */
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM ("cpsid f"); }
S
S#define __NOP                                     __no_operation()          /*!< no operation intrinsic in IAR Compiler */ 
Sstatic __INLINE  void __WFI()                     { __ASM ("wfi"); }
Sstatic __INLINE  void __WFE()                     { __ASM ("wfe"); }
Sstatic __INLINE  void __SEV()                     { __ASM ("sev"); }
Sstatic __INLINE  void __CLREX()                   { __ASM ("clrex"); }
S
S/* intrinsic void __ISB(void)                                     */
S/* intrinsic void __DSB(void)                                     */
S/* intrinsic void __DMB(void)                                     */
S/* intrinsic void __set_PRIMASK();                                */
S/* intrinsic void __get_PRIMASK();                                */
S/* intrinsic void __set_FAULTMASK();                              */
S/* intrinsic void __get_FAULTMASK();                              */
S/* intrinsic uint32_t __REV(uint32_t value);                      */
S/* intrinsic uint32_t __REVSH(uint32_t value);                    */
S/* intrinsic unsigned long __STREX(unsigned long, unsigned long); */
S/* intrinsic unsigned long __LDREX(unsigned long *);              */
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @param  none
S * @return uint32_t ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  uint32_t Process Stack Pointer
S * @return none
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @param  none
S * @return uint32_t Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  uint32_t Main Stack Pointer
S * @return none
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  uint16_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint8_t* address
S * @return uint8_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint16_t* address
S * @return uint16_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint32_t* address
S * @return uint32_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint8_t *address
S * @param  uint8_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint16_t *address
S * @param  uint16_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint32_t *address
S * @param  uint32_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S
S#elif (defined (__GNUC__)) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
Sstatic __INLINE void __enable_irq()               { __ASM volatile ("cpsie i"); }
Sstatic __INLINE void __disable_irq()              { __ASM volatile ("cpsid i"); }
S
Sstatic __INLINE void __enable_fault_irq()         { __ASM volatile ("cpsie f"); }
Sstatic __INLINE void __disable_fault_irq()        { __ASM volatile ("cpsid f"); }
S
Sstatic __INLINE void __NOP()                      { __ASM volatile ("nop"); }
Sstatic __INLINE void __WFI()                      { __ASM volatile ("wfi"); }
Sstatic __INLINE void __WFE()                      { __ASM volatile ("wfe"); }
Sstatic __INLINE void __SEV()                      { __ASM volatile ("sev"); }
Sstatic __INLINE void __ISB()                      { __ASM volatile ("isb"); }
Sstatic __INLINE void __DSB()                      { __ASM volatile ("dsb"); }
Sstatic __INLINE void __DMB()                      { __ASM volatile ("dmb"); }
Sstatic __INLINE void __CLREX()                    { __ASM volatile ("clrex"); }
S
S
S/**
S * @brief  Return the Process Stack Pointer
S *
S * @param  none
S * @return uint32_t ProcessStackPointer
S *
S * Return the actual process stack pointer
S */
Sextern uint32_t __get_PSP(void);
S
S/**
S * @brief  Set the Process Stack Pointer
S *
S * @param  uint32_t Process Stack Pointer
S * @return none
S *
S * Assign the value ProcessStackPointer to the MSP 
S * (process stack pointer) Cortex processor register
S */
Sextern void __set_PSP(uint32_t topOfProcStack);
S
S/**
S * @brief  Return the Main Stack Pointer
S *
S * @param  none
S * @return uint32_t Main Stack Pointer
S *
S * Return the current value of the MSP (main stack pointer)
S * Cortex processor register
S */
Sextern uint32_t __get_MSP(void);
S
S/**
S * @brief  Set the Main Stack Pointer
S *
S * @param  uint32_t Main Stack Pointer
S * @return none
S *
S * Assign the value mainStackPointer to the MSP 
S * (main stack pointer) Cortex processor register
S */
Sextern void __set_MSP(uint32_t topOfMainStack);
S
S/**
S * @brief  Return the Base Priority value
S *
S * @param  none
S * @return uint32_t BasePriority
S *
S * Return the content of the base priority register
S */
Sextern uint32_t __get_BASEPRI(void);
S
S/**
S * @brief  Set the Base Priority value
S *
S * @param  uint32_t BasePriority
S * @return none
S *
S * Set the base priority register
S */
Sextern void __set_BASEPRI(uint32_t basePri);
S
S/**
S * @brief  Return the Priority Mask value
S *
S * @param  none
S * @return uint32_t PriMask
S *
S * Return the state of the priority mask bit from the priority mask
S * register
S */
Sextern uint32_t  __get_PRIMASK(void);
S
S/**
S * @brief  Set the Priority Mask value
S *
S * @param  uint32_t PriMask
S * @return none
S *
S * Set the priority mask bit in the priority mask register
S */
Sextern void __set_PRIMASK(uint32_t priMask);
S
S/**
S * @brief  Return the Fault Mask value
S *
S * @param  none
S * @return uint32_t FaultMask
S *
S * Return the content of the fault mask register
S */
Sextern uint32_t __get_FAULTMASK(void);
S
S/**
S * @brief  Set the Fault Mask value
S *
S * @param  uint32_t faultMask value
S * @return none
S *
S * Set the fault mask register
S */
Sextern void __set_FAULTMASK(uint32_t faultMask);
S
S/**
S * @brief  Return the Control Register value
S* 
S*  @param  none
S*  @return uint32_t Control value
S *
S * Return the content of the control register
S */
Sextern uint32_t __get_CONTROL(void);
S
S/**
S * @brief  Set the Control Register value
S *
S * @param  uint32_t Control value
S * @return none
S *
S * Set the control register
S */
Sextern void __set_CONTROL(uint32_t control);
S
S/**
S * @brief  Reverse byte order in integer value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in integer value
S */
Sextern uint32_t __REV(uint32_t value);
S
S/**
S * @brief  Reverse byte order in unsigned short value
S *
S * @param  uint16_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse byte order in unsigned short value
S */
Sextern uint32_t __REV16(uint16_t value);
S
S/*
S * Reverse byte order in signed short value with sign extension to integer
S *
S * @param  int16_t value to reverse
S * @return int32_t reversed value
S *
S * @brief  Reverse byte order in signed short value with sign extension to integer
S */
Sextern int32_t __REVSH(int16_t value);
S
S/**
S * @brief  Reverse bit order of value
S *
S * @param  uint32_t value to reverse
S * @return uint32_t reversed value
S *
S * Reverse bit order of value
S */
Sextern uint32_t __RBIT(uint32_t value);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint8_t* address
S * @return uint8_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint8_t __LDREXB(uint8_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint16_t* address
S * @return uint16_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint16_t __LDREXH(uint16_t *addr);
S
S/**
S * @brief  LDR Exclusive
S *
S * @param  uint32_t* address
S * @return uint32_t value of (*address)
S *
S * Exclusive LDR command
S */
Sextern uint32_t __LDREXW(uint32_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint8_t *address
S * @param  uint8_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXB(uint8_t value, uint8_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint16_t *address
S * @param  uint16_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXH(uint16_t value, uint16_t *addr);
S
S/**
S * @brief  STR Exclusive
S *
S * @param  uint32_t *address
S * @param  uint32_t value to store
S * @return uint32_t successful / failed
S *
S * Exclusive STR command
S */
Sextern uint32_t __STREXW(uint32_t value, uint32_t *addr);
S
S
S#elif (defined (__TASKING__)) /*------------------ TASKING Compiler ---------------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N
N
N/* ##########################   NVIC functions  #################################### */
N
N
N/**
N * @brief  Set the Priority Grouping in NVIC Interrupt Controller
N *
N * @param  uint32_t priority_grouping is priority grouping field
N * @return none 
N *
N * Set the priority grouping field using the required unlock sequence.
N * The parameter priority_grouping is assigned to the field 
N * SCB->AIRCR [10:8] PRIGROUP field. Only values from 0..7 are used.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N */
Nstatic __INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
Xstatic __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
N{
N  uint32_t reg_value;
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  
N  reg_value  = SCB->AIRCR;                                                    /* read old register configuration    */
X  reg_value  = ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR;                                                     
N  reg_value &= ~((0xFFFFU << 16) | (0x0F << 8));                              /* clear bits to change               */
N  reg_value  = ((reg_value | NVIC_AIRCR_VECTKEY | (PriorityGroupTmp << 8)));  /* Insert write key and priorty group */
X  reg_value  = ((reg_value | (0x5FA << 16) | (PriorityGroupTmp << 8)));   
N  SCB->AIRCR = reg_value;
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR = reg_value;
N}
N
N/**
N * @brief  Get the Priority Grouping from NVIC Interrupt Controller
N *
N * @param  none
N * @return uint32_t   priority grouping field 
N *
N * Get the priority grouping from NVIC Interrupt Controller.
N * priority grouping is SCB->AIRCR [10:8] PRIGROUP field.
N */
Nstatic __INLINE uint32_t NVIC_GetPriorityGrouping(void)
Xstatic __inline uint32_t NVIC_GetPriorityGrouping(void)
N{
N  return ((SCB->AIRCR >> 8) & 0x07);                                          /* read priority grouping field */
X  return ((((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR >> 8) & 0x07);                                           
N}
N
N/**
N * @brief  Enable Interrupt in NVIC Interrupt Controller
N *
N * @param  IRQn_Type IRQn specifies the interrupt number
N * @return none 
N *
N * Enable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* enable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Disable the interrupt line for external interrupt specified
N * 
N * @param  IRQn_Type IRQn is the positive number of the external interrupt
N * @return none
N * 
N * Disable a device specific interupt in the NVIC interrupt controller.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* disable interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICER[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the interrupt pending bit for a device specific interrupt source
N * 
N * @param  IRQn_Type IRQn is the number of the device specifc interrupt
N * @return uint32_t 1 if pending interrupt else 0
N *
N * Read the pending register in NVIC and return 1 if its status is pending, 
N * otherwise it returns 0
N */
Nstatic __INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if pending else 0 */
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the pending bit for an external interrupt
N * 
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return none
N *
N * Set the pending bit for the specified interrupt.
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* set interrupt pending */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ISPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Clear the pending bit for an external interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return none
N *
N * Clear the pending bit for the specified interrupt. 
N * The interrupt number cannot be a negative value.
N */
Nstatic __INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000) + 0x0100))->ICPR[((uint32_t)(IRQn) >> 5)] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N/**
N * @brief  Read the active bit for an external interrupt
N *
N * @param  IRQn_Type  IRQn is the Number of the interrupt
N * @return uint32_t   1 if active else 0
N *
N * Read the active register in NVIC and returns 1 if its status is active, 
N * otherwise it returns 0.
N */
Nstatic __INLINE uint32_t NVIC_GetActive(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
N{
N  return((uint32_t)((NVIC->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0)); /* Return 1 if active else 0 */
X  return((uint32_t)((((NVIC_Type *) ((0xE000E000) + 0x0100))->IABR[(uint32_t)(IRQn) >> 5] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));  
N}
N
N/**
N * @brief  Set the priority for an interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @param  priority is the priority for the interrupt
N * @return none
N *
N * Set the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt. \n
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M3 System Interrupts */
X    ((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - 5)) & 0xff); }  
N  else {
N    NVIC->IP[(uint32_t)(IRQn)] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff);    }        /* set Priority for device specific Interrupts      */
X    ((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)] = ((priority << (8 - 5)) & 0xff);    }         
N}
N
N/**
N * @brief  Read the priority for an interrupt
N *
N * @param  IRQn_Type IRQn is the Number of the interrupt
N * @return uint32_t  priority is the priority for the interrupt
N *
N * Read the priority for the specified interrupt. The interrupt 
N * number can be positive to specify an external (device specific) 
N * interrupt, or negative to specify an internal (core) interrupt.
N *
N * The returned priority value is automatically aligned to the implemented
N * priority bits of the microcontroller.
N *
N * Note: The priority cannot be set for every core interrupt.
N */
Nstatic __INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)(SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M3 system interrupts */
X    return((uint32_t)(((SCB_Type *) ((0xE000E000) + 0x0D00))->SHP[((uint32_t)(IRQn) & 0xF)-4] >> (8 - 5)));  }  
N  else {
N    return((uint32_t)(NVIC->IP[(uint32_t)(IRQn)]           >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)(((NVIC_Type *) ((0xE000E000) + 0x0100))->IP[(uint32_t)(IRQn)]           >> (8 - 5)));  }  
N}
N
N
N/**
N * @brief  Encode the priority for an interrupt
N *
N * @param  uint32_t PriorityGroup   is the used priority group
N * @param  uint32_t PreemptPriority is the preemptive priority value (starting from 0)
N * @param  uint32_t SubPriority     is the sub priority value (starting from 0)
N * @return uint32_t                    the priority for the interrupt
N *
N * Encode the priority for an interrupt with the given priority group,
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The returned priority value can be used for NVIC_SetPriority(...) function
N */
Nstatic __INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N 
N  return (
N           ((PreemptPriority & ((1 << (PreemptPriorityBits)) - 1)) << SubPriorityBits) |
N           ((SubPriority     & ((1 << (SubPriorityBits    )) - 1)))
N         );
N}
N
N
N/**
N * @brief  Decode the priority of an interrupt
N *
N * @param  uint32_t   Priority       the priority for the interrupt
N * @param  uint32_t   PrioGroup   is the used priority group
N * @param  uint32_t* pPreemptPrio is the preemptive priority value (starting from 0)
N * @param  uint32_t* pSubPrio     is the sub priority value (starting from 0)
N * @return none
N *
N * Decode an interrupt priority value with the given priority group to 
N * preemptive priority value and sub priority value.
N * In case of a conflict between priority grouping and available
N * priority bits (__NVIC_PRIO_BITS) the samllest possible priority group is set.
N *
N * The priority value can be retrieved with NVIC_GetPriority(...) function
N */
Nstatic __INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* pPreemptPriority, uint32_t* pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & 0x07);                         /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7 - PriorityGroupTmp) > __NVIC_PRIO_BITS) ? __NVIC_PRIO_BITS : 7 - PriorityGroupTmp;
X  PreemptPriorityBits = ((7 - PriorityGroupTmp) > 5) ? 5 : 7 - PriorityGroupTmp;
N  SubPriorityBits     = ((PriorityGroupTmp + __NVIC_PRIO_BITS) < 7) ? 0 : PriorityGroupTmp - 7 + __NVIC_PRIO_BITS;
X  SubPriorityBits     = ((PriorityGroupTmp + 5) < 7) ? 0 : PriorityGroupTmp - 7 + 5;
N  
N  *pPreemptPriority = (Priority >> SubPriorityBits) & ((1 << (PreemptPriorityBits)) - 1);
N  *pSubPriority     = (Priority                   ) & ((1 << (SubPriorityBits    )) - 1);
N}
N
N
N
N/* ##################################    SysTick function  ############################################ */
N
N#if (!defined (__Vendor_SysTickConfig)) || (__Vendor_SysTickConfig == 0)
X#if (!1L) || (0 == 0)
N
N/* SysTick constants */
N#define SYSTICK_ENABLE              0                                          /* Config-Bit to start or stop the SysTick Timer                         */
N#define SYSTICK_TICKINT             1                                          /* Config-Bit to enable or disable the SysTick interrupt                 */
N#define SYSTICK_CLKSOURCE           2                                          /* Clocksource has the offset 2 in SysTick Control and Status Register   */
N#define SYSTICK_MAXCOUNT       ((1<<24) -1)                                    /* SysTick MaxCount                                                      */
N
N/**
N * @brief  Initialize and start the SysTick counter and its interrupt.
N *
N * @param  uint32_t ticks is the number of ticks between two interrupts
N * @return  none
N *
N * Initialise the system tick timer and its interrupt and start the
N * system tick timer / counter in free running mode to generate 
N * periodical interrupts.
N */
Nstatic __INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{ 
N  if (ticks > SYSTICK_MAXCOUNT)  return (1);                                             /* Reload value impossible */
X  if (ticks > ((1<<24) -1))  return (1);                                              
N
N  SysTick->LOAD  =  (ticks & SYSTICK_MAXCOUNT) - 1;                                      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->LOAD  =  (ticks & ((1<<24) -1)) - 1;                                       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);                            /* set Priority for Cortex-M0 System Interrupts */
X  NVIC_SetPriority (SysTick_IRQn, (1<<5) - 1);                             
N  SysTick->VAL   =  (0x00);                                                              /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->VAL   =  (0x00);                                                               
N  SysTick->CTRL = (1 << SYSTICK_CLKSOURCE) | (1<<SYSTICK_ENABLE) | (1<<SYSTICK_TICKINT); /* Enable SysTick IRQ and SysTick Timer */
X  ((SysTick_Type *) ((0xE000E000) + 0x0010))->CTRL = (1 << 2) | (1<<0) | (1<<1);  
N  return (0);                                                                            /* Function successful */
N}
N
N#endif
N
N
N
N
N
N/* ##################################    Reset function  ############################################ */
N
N/**
N * @brief  Initiate a system reset request.
N *
N * @param   none
N * @return  none
N *
N * Initialize a system reset request to reset the MCU
N */
Nstatic __INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  SCB->AIRCR  = (NVIC_AIRCR_VECTKEY | (SCB->AIRCR & (0x700)) | (1<<NVIC_SYSRESETREQ)); /* Keep priority group unchanged */
X  ((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR  = ((0x5FA << 16) | (((SCB_Type *) ((0xE000E000) + 0x0D00))->AIRCR & (0x700)) | (1<<2));  
N  __DSB();                                                                             /* Ensure completion of memory access */              
X  __dsb(0);                                                                                            
N  while(1);                                                                            /* wait until reset */
N}
N
N
N/* ##################################    Debug Output  function  ############################################ */
N
N
N/**
N * @brief  Outputs a character via the ITM channel 0
N *
N * @param   uint32_t character to output
N * @return  uint32_t input character
N *
N * The function outputs a character via the ITM channel 0. 
N * The function returns when no debugger is connected that has booked the output.  
N * It is blocking when a debugger is connected, but the previous character send is not transmitted. 
N */
Nstatic __INLINE uint32_t ITM_SendChar (uint32_t ch)
Xstatic __inline uint32_t ITM_SendChar (uint32_t ch)
N{
N  if (ch == '\n') ITM_SendChar('\r');
N  
N  if ((CoreDebug->DEMCR & CoreDebug_DEMCR_TRCENA)  &&
X  if ((((CoreDebug_Type *) (0xE000EDF0))->DEMCR & (1 << 24))  &&
N      (ITM->TCR & ITM_TCR_ITMENA)                  &&
X      (((ITM_Type *) (0xE0000000))->TCR & 1)                  &&
N      (ITM->TER & (1UL << 0))  ) 
X      (((ITM_Type *) (0xE0000000))->TER & (1UL << 0))  ) 
N  {
N    while (ITM->PORT[0].u32 == 0);
X    while (((ITM_Type *) (0xE0000000))->PORT[0].u32 == 0);
N    ITM->PORT[0].u8 = (uint8_t) ch;
X    ((ITM_Type *) (0xE0000000))->PORT[0].u8 = (uint8_t) ch;
N  }  
N  return (ch);
N}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CM3_CORE_H__ */
N
N/*lint -restore */
L 105 "LPC17xx.h" 2
N#include "system_LPC17xx.h"                 /* System Header                                      */
L 1 "system_LPC17xx.h" 1
N/**************************************************************************//**
N * @file     system_LPC17xx.h
N * @brief    CMSIS Cortex-M3 Device System Header File for
N *           NXP LPC17xx Device Series
N * @version  V1.10
N * @date     06. April 2011
N *
N * @note
N * Copyright (C) 2009-2011 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N
N#ifndef __SYSTEM_LPC17xx_H
N#define __SYSTEM_LPC17xx_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <stdint.h>
N
N/** @addtogroup LPC17xx_System
N * @{
N */
N
Nextern uint32_t SystemFrequency;     /*!< System Clock Frequency (Core Clock)  */
N
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system.
N *         Initialize the System.
N */
Nextern void SystemInit (void);
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N/**
N * @}
N */
N
N#endif /* __SYSTEM_LPC17xx_H */
L 106 "LPC17xx.h" 2
N
N
N/******************************************************************************/
N/*                Device Specific Peripheral registers structures             */
N/******************************************************************************/
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N/*------------- System Control (SC) ------------------------------------------*/
N/** @brief System Control (SC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t FLASHCFG;                   /*!< Offset: 0x000 (R/W)  Flash Accelerator Configuration Register */
X  volatile uint32_t FLASHCFG;                    
N       uint32_t RESERVED0[31];
N  __IO uint32_t PLL0CON;                    /*!< Offset: 0x080 (R/W)  PLL0 Control Register */
X  volatile uint32_t PLL0CON;                     
N  __IO uint32_t PLL0CFG;                    /*!< Offset: 0x084 (R/W)  PLL0 Configuration Register */
X  volatile uint32_t PLL0CFG;                     
N  __I  uint32_t PLL0STAT;                   /*!< Offset: 0x088 (R/ )  PLL0 Status Register */
X  volatile const  uint32_t PLL0STAT;                    
N  __O  uint32_t PLL0FEED;                   /*!< Offset: 0x08C ( /W)  PLL0 Feed Register */
X  volatile  uint32_t PLL0FEED;                    
N       uint32_t RESERVED1[4];
N  __IO uint32_t PLL1CON;                    /*!< Offset: 0x0A0 (R/W)  PLL1 Control Register */
X  volatile uint32_t PLL1CON;                     
N  __IO uint32_t PLL1CFG;                    /*!< Offset: 0x0A4 (R/W)  PLL1 Configuration Register */
X  volatile uint32_t PLL1CFG;                     
N  __I  uint32_t PLL1STAT;                   /*!< Offset: 0x0A8 (R/ )  PLL1 Status Register */
X  volatile const  uint32_t PLL1STAT;                    
N  __O  uint32_t PLL1FEED;                   /*!< Offset: 0x0AC ( /W)  PLL1 Feed Register */
X  volatile  uint32_t PLL1FEED;                    
N       uint32_t RESERVED2[4];
N  __IO uint32_t PCON;                       /*!< Offset: 0x0C0 (R/W)  Power Control Register */
X  volatile uint32_t PCON;                        
N  __IO uint32_t PCONP;                      /*!< Offset: 0x0C4 (R/W)  Power Control for Peripherals Register */
X  volatile uint32_t PCONP;                       
N       uint32_t RESERVED3[15];
N  __IO uint32_t CCLKCFG;                    /*!< Offset: 0x104 (R/W)  CPU Clock Configure Register  */
X  volatile uint32_t CCLKCFG;                     
N  __IO uint32_t USBCLKCFG;                  /*!< Offset: 0x108 (R/W)  USB Clock Configure Register */
X  volatile uint32_t USBCLKCFG;                   
N  __IO uint32_t CLKSRCSEL;                  /*!< Offset: 0x10C (R/W)  Clock Source Select Register */
X  volatile uint32_t CLKSRCSEL;                   
N  __IO uint32_t CANSLEEPCLR;                /*!< Offset: 0x110 (R/W)  CAN Sleep Clear Register */
X  volatile uint32_t CANSLEEPCLR;                 
N  __IO uint32_t CANWAKEFLAGS;               /*!< Offset: 0x114 (R/W)  CAN Wake-up Flags Register */
X  volatile uint32_t CANWAKEFLAGS;                
N       uint32_t RESERVED4[10];
N  __IO uint32_t EXTINT;                     /*!< Offset: 0x140 (R/W)  External Interrupt Flag Register */
X  volatile uint32_t EXTINT;                      
N       uint32_t RESERVED5[1];
N  __IO uint32_t EXTMODE;                    /*!< Offset: 0x148 (R/W)  External Interrupt Mode Register */
X  volatile uint32_t EXTMODE;                     
N  __IO uint32_t EXTPOLAR;                   /*!< Offset: 0x14C (R/W)  External Interrupt Polarity Register */
X  volatile uint32_t EXTPOLAR;                    
N       uint32_t RESERVED6[12];
N  __IO uint32_t RSID;                       /*!< Offset: 0x180 (R/W)  Reset Source Identification Register */
X  volatile uint32_t RSID;                        
N       uint32_t RESERVED7[7];
N  __IO uint32_t SCS;                        /*!< Offset: 0x1A0 (R/W)  System Controls and Status Register */
X  volatile uint32_t SCS;                         
N  __IO uint32_t IRCTRIM;                /* Clock Dividers                     */
X  volatile uint32_t IRCTRIM;                 
N  __IO uint32_t PCLKSEL0;                   /*!< Offset: 0x1A8 (R/W)  Peripheral Clock Select 0 Register */
X  volatile uint32_t PCLKSEL0;                    
N  __IO uint32_t PCLKSEL1;                   /*!< Offset: 0x1AC (R/W)  Peripheral Clock Select 1 Register */
X  volatile uint32_t PCLKSEL1;                    
N       uint32_t RESERVED8[4];
N  __IO uint32_t USBIntSt;                   /*!< Offset: 0x1C0 (R/W)  USB Interrupt Status Register */
X  volatile uint32_t USBIntSt;                    
N  __IO uint32_t DMAREQSEL;                  /*!< Offset: 0x1C4 (R/W)  DMA Request Select Register */
X  volatile uint32_t DMAREQSEL;                   
N  __IO uint32_t CLKOUTCFG;                  /*!< Offset: 0x1C8 (R/W)  Clock Output Configuration Register */
X  volatile uint32_t CLKOUTCFG;                   
N
N } LPC_SC_TypeDef;
N
N/*------------- Pin Connect Block (PINCON) -----------------------------------*/
N/** @brief Pin Connect Block (PINCON) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t PINSEL0;				 /* !< Offset: 0x000 PIN Select0 (R/W) */
X  volatile uint32_t PINSEL0;				  
N  __IO uint32_t PINSEL1;				 /* !< Offset: 0x004 PIN Select1 (R/W) */
X  volatile uint32_t PINSEL1;				  
N  __IO uint32_t PINSEL2;				 /* !< Offset: 0x008 PIN Select2 (R/W) */
X  volatile uint32_t PINSEL2;				  
N  __IO uint32_t PINSEL3;				 /* !< Offset: 0x00C PIN Select3 (R/W) */
X  volatile uint32_t PINSEL3;				  
N  __IO uint32_t PINSEL4;				 /* !< Offset: 0x010 PIN Select4 (R/W) */
X  volatile uint32_t PINSEL4;				  
N  __IO uint32_t PINSEL5;				 /* !< Offset: 0x014 PIN Select5 (R/W) */
X  volatile uint32_t PINSEL5;				  
N  __IO uint32_t PINSEL6;				 /* !< Offset: 0x018 PIN Select6 (R/W) */
X  volatile uint32_t PINSEL6;				  
N  __IO uint32_t PINSEL7;				 /* !< Offset: 0x01C PIN Select7 (R/W) */
X  volatile uint32_t PINSEL7;				  
N  __IO uint32_t PINSEL8;				 /* !< Offset: 0x020 PIN Select8 (R/W) */
X  volatile uint32_t PINSEL8;				  
N  __IO uint32_t PINSEL9;				 /* !< Offset: 0x024 PIN Select9 (R/W) */
X  volatile uint32_t PINSEL9;				  
N  __IO uint32_t PINSEL10;				 /* !< Offset: 0x028 PIN Select20 (R/W) */
X  volatile uint32_t PINSEL10;				  
N       uint32_t RESERVED0[5];
N  __IO uint32_t PINMODE0;				 /* !< Offset: 0x040 PIN Mode0 (R/W) */
X  volatile uint32_t PINMODE0;				  
N  __IO uint32_t PINMODE1;				 /* !< Offset: 0x044 PIN Mode1 (R/W) */
X  volatile uint32_t PINMODE1;				  
N  __IO uint32_t PINMODE2;				 /* !< Offset: 0x048 PIN Mode2 (R/W) */
X  volatile uint32_t PINMODE2;				  
N  __IO uint32_t PINMODE3;				 /* !< Offset: 0x04C PIN Mode3 (R/W) */
X  volatile uint32_t PINMODE3;				  
N  __IO uint32_t PINMODE4;				 /* !< Offset: 0x050 PIN Mode4 (R/W) */
X  volatile uint32_t PINMODE4;				  
N  __IO uint32_t PINMODE5;				 /* !< Offset: 0x054 PIN Mode5 (R/W) */
X  volatile uint32_t PINMODE5;				  
N  __IO uint32_t PINMODE6;				 /* !< Offset: 0x058 PIN Mode6 (R/W) */
X  volatile uint32_t PINMODE6;				  
N  __IO uint32_t PINMODE7;				 /* !< Offset: 0x05C PIN Mode7 (R/W) */
X  volatile uint32_t PINMODE7;				  
N  __IO uint32_t PINMODE8;				 /* !< Offset: 0x060 PIN Mode8 (R/W) */
X  volatile uint32_t PINMODE8;				  
N  __IO uint32_t PINMODE9;				 /* !< Offset: 0x064 PIN Mode9 (R/W) */
X  volatile uint32_t PINMODE9;				  
N  __IO uint32_t PINMODE_OD0;			 /* !< Offset: 0x068 Open Drain PIN Mode0 (R/W) */
X  volatile uint32_t PINMODE_OD0;			  
N  __IO uint32_t PINMODE_OD1;			 /* !< Offset: 0x06C Open Drain PIN Mode1 (R/W) */
X  volatile uint32_t PINMODE_OD1;			  
N  __IO uint32_t PINMODE_OD2;			 /* !< Offset: 0x070 Open Drain PIN Mode2 (R/W) */
X  volatile uint32_t PINMODE_OD2;			  
N  __IO uint32_t PINMODE_OD3;			 /* !< Offset: 0x074 Open Drain PIN Mode3 (R/W) */
X  volatile uint32_t PINMODE_OD3;			  
N  __IO uint32_t PINMODE_OD4;			 /* !< Offset: 0x078 Open Drain PIN Mode4 (R/W) */
X  volatile uint32_t PINMODE_OD4;			  
N  __IO uint32_t I2CPADCFG;				 /* !< Offset: 0x07C I2C Pad Configure (R/W) */
X  volatile uint32_t I2CPADCFG;				  
N} LPC_PINCON_TypeDef;
N
N/*------------- General Purpose Input/Output (GPIO) --------------------------*/
N/** @brief General Purpose Input/Output (GPIO) register structure definition */
Ntypedef struct
N{
N  union {
N    __IO uint32_t FIODIR;				 /* !< Offset: 0x00 Port direction (R/W) */
X    volatile uint32_t FIODIR;				  
N    struct {
N      __IO uint16_t FIODIRL;
X      volatile uint16_t FIODIRL;
N      __IO uint16_t FIODIRH;
X      volatile uint16_t FIODIRH;
N    };
N    struct {
N      __IO uint8_t  FIODIR0;
X      volatile uint8_t  FIODIR0;
N      __IO uint8_t  FIODIR1;
X      volatile uint8_t  FIODIR1;
N      __IO uint8_t  FIODIR2;
X      volatile uint8_t  FIODIR2;
N      __IO uint8_t  FIODIR3;
X      volatile uint8_t  FIODIR3;
N    };
N  };
N  uint32_t RESERVED0[3];
N  union {
N    __IO uint32_t FIOMASK;				 /* !< Offset: 0x10 Port mask (R/W) */
X    volatile uint32_t FIOMASK;				  
N    struct {
N      __IO uint16_t FIOMASKL;
X      volatile uint16_t FIOMASKL;
N      __IO uint16_t FIOMASKH;
X      volatile uint16_t FIOMASKH;
N    };
N    struct {
N      __IO uint8_t  FIOMASK0;
X      volatile uint8_t  FIOMASK0;
N      __IO uint8_t  FIOMASK1;
X      volatile uint8_t  FIOMASK1;
N      __IO uint8_t  FIOMASK2;
X      volatile uint8_t  FIOMASK2;
N      __IO uint8_t  FIOMASK3;
X      volatile uint8_t  FIOMASK3;
N    };
N  };
N  union {
N    __IO uint32_t FIOPIN;				 /* !< Offset: 0x14 Port value (R/W) */
X    volatile uint32_t FIOPIN;				  
N    struct {
N      __IO uint16_t FIOPINL;
X      volatile uint16_t FIOPINL;
N      __IO uint16_t FIOPINH;
X      volatile uint16_t FIOPINH;
N    };
N    struct {
N      __IO uint8_t  FIOPIN0;
X      volatile uint8_t  FIOPIN0;
N      __IO uint8_t  FIOPIN1;
X      volatile uint8_t  FIOPIN1;
N      __IO uint8_t  FIOPIN2;
X      volatile uint8_t  FIOPIN2;
N      __IO uint8_t  FIOPIN3;
X      volatile uint8_t  FIOPIN3;
N    };
N  };
N  union {
N    __IO uint32_t FIOSET;				 /* !< Offset: 0x18 Port output set (R/W) */
X    volatile uint32_t FIOSET;				  
N    struct {
N      __IO uint16_t FIOSETL;
X      volatile uint16_t FIOSETL;
N      __IO uint16_t FIOSETH;
X      volatile uint16_t FIOSETH;
N    };
N    struct {
N      __IO uint8_t  FIOSET0;
X      volatile uint8_t  FIOSET0;
N      __IO uint8_t  FIOSET1;
X      volatile uint8_t  FIOSET1;
N      __IO uint8_t  FIOSET2;
X      volatile uint8_t  FIOSET2;
N      __IO uint8_t  FIOSET3;
X      volatile uint8_t  FIOSET3;
N    };
N  };
N  union {
N    __O  uint32_t FIOCLR;				 /* !< Offset: 0x1C Port output clear (R/W) */
X    volatile  uint32_t FIOCLR;				  
N    struct {
N      __O  uint16_t FIOCLRL;
X      volatile  uint16_t FIOCLRL;
N      __O  uint16_t FIOCLRH;
X      volatile  uint16_t FIOCLRH;
N    };
N    struct {
N      __O  uint8_t  FIOCLR0;
X      volatile  uint8_t  FIOCLR0;
N      __O  uint8_t  FIOCLR1;
X      volatile  uint8_t  FIOCLR1;
N      __O  uint8_t  FIOCLR2;
X      volatile  uint8_t  FIOCLR2;
N      __O  uint8_t  FIOCLR3;
X      volatile  uint8_t  FIOCLR3;
N    };
N  };
N} LPC_GPIO_TypeDef;
N
N/** @brief General Purpose Input/Output interrupt (GPIOINT) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t IntStatus;                  /*!< Offset: 0x000 (R/ )  GPIO overall Interrupt Status Register */
X  volatile const  uint32_t IntStatus;                   
N  __I  uint32_t IO0IntStatR;                /*!< Offset: 0x004 (R/ )  GPIO Interrupt Status Register 0 for Rising edge */
X  volatile const  uint32_t IO0IntStatR;                 
N  __I  uint32_t IO0IntStatF;                /*!< Offset: 0x008 (R/ )  GPIO Interrupt Status Register 0 for Falling edge */
X  volatile const  uint32_t IO0IntStatF;                 
N  __O  uint32_t IO0IntClr;                  /*!< Offset: 0x00C (R/W)  GPIO Interrupt Clear  Register 0 */
X  volatile  uint32_t IO0IntClr;                   
N  __IO uint32_t IO0IntEnR;                  /*!< Offset: 0x010 ( /W)  GPIO Interrupt Enable Register 0 for Rising edge */
X  volatile uint32_t IO0IntEnR;                   
N  __IO uint32_t IO0IntEnF;                  /*!< Offset: 0x014 (R/W)  GPIO Interrupt Enable Register 0 for Falling edge */
X  volatile uint32_t IO0IntEnF;                   
N       uint32_t RESERVED0[3];
N  __I  uint32_t IO2IntStatR;                /*!< Offset: 0x000 (R/ )  GPIO Interrupt Status Register 2 for Rising edge */
X  volatile const  uint32_t IO2IntStatR;                 
N  __I  uint32_t IO2IntStatF;                /*!< Offset: 0x000 (R/ )  GPIO Interrupt Status Register 2 for Falling edge */
X  volatile const  uint32_t IO2IntStatF;                 
N  __O  uint32_t IO2IntClr;                  /*!< Offset: 0x000 ( /W)  GPIO Interrupt Clear  Register 2 */
X  volatile  uint32_t IO2IntClr;                   
N  __IO uint32_t IO2IntEnR;                  /*!< Offset: 0x000 (R/W)  GPIO Interrupt Enable Register 2 for Rising edge */
X  volatile uint32_t IO2IntEnR;                   
N  __IO uint32_t IO2IntEnF;                  /*!< Offset: 0x000 (R/W)  GPIO Interrupt Enable Register 2 for Falling edge */
X  volatile uint32_t IO2IntEnF;                   
N} LPC_GPIOINT_TypeDef;
N
N/*------------- Timer (TIM) --------------------------------------------------*/
N/** @brief Timer (TIM) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t IR;                         /*!< Offset: 0x000 (R/W)  Interrupt Register */
X  volatile uint32_t IR;                          
N  __IO uint32_t TCR;                        /*!< Offset: 0x004 (R/W)  Timer Control Register */
X  volatile uint32_t TCR;                         
N  __IO uint32_t TC;                         /*!< Offset: 0x008 (R/W)  Timer Counter Register */
X  volatile uint32_t TC;                          
N  __IO uint32_t PR;                         /*!< Offset: 0x00C (R/W)  Prescale Register */
X  volatile uint32_t PR;                          
N  __IO uint32_t PC;                         /*!< Offset: 0x010 (R/W)  Prescale Counter Register */
X  volatile uint32_t PC;                          
N  __IO uint32_t MCR;                        /*!< Offset: 0x014 (R/W)  Match Control Register */
X  volatile uint32_t MCR;                         
N  __IO uint32_t MR0;                        /*!< Offset: 0x018 (R/W)  Match Register 0 */
X  volatile uint32_t MR0;                         
N  __IO uint32_t MR1;                        /*!< Offset: 0x01C (R/W)  Match Register 1 */
X  volatile uint32_t MR1;                         
N  __IO uint32_t MR2;                        /*!< Offset: 0x020 (R/W)  Match Register 2 */
X  volatile uint32_t MR2;                         
N  __IO uint32_t MR3;                        /*!< Offset: 0x024 (R/W)  Match Register 3 */
X  volatile uint32_t MR3;                         
N  __IO uint32_t CCR;                        /*!< Offset: 0x028 (R/W)  Capture Control Register */
X  volatile uint32_t CCR;                         
N  __I  uint32_t CR0;                        /*!< Offset: 0x02C (R/ )  Capture Register 0 */
X  volatile const  uint32_t CR0;                         
N  __I  uint32_t CR1;                        /*!< Offset: 0x030 (R/ )  Capture Register */
X  volatile const  uint32_t CR1;                         
N       uint32_t RESERVED0[2];
N  __IO uint32_t EMR;                        /*!< Offset: 0x03C (R/W)  External Match Register */
X  volatile uint32_t EMR;                         
N       uint32_t RESERVED1[12];
N  __IO uint32_t CTCR;                       /*!< Offset: 0x070 (R/W)  Count Control Register */
X  volatile uint32_t CTCR;                        
N} LPC_TIM_TypeDef;
N
N/*------------- Pulse-Width Modulation (PWM) ---------------------------------*/
N/** @brief Pulse-Width Modulation (PWM) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t IR;                         /*!< Offset: 0x000 (R/W)  Interrupt Register */
X  volatile uint32_t IR;                          
N  __IO uint32_t TCR;                        /*!< Offset: 0x004 (R/W)  Timer Control Register. Register */
X  volatile uint32_t TCR;                         
N  __IO uint32_t TC;                         /*!< Offset: 0x008 (R/W)  Timer Counter Register */
X  volatile uint32_t TC;                          
N  __IO uint32_t PR;                         /*!< Offset: 0x00C (R/W)  Prescale Register */
X  volatile uint32_t PR;                          
N  __IO uint32_t PC;                         /*!< Offset: 0x010 (R/W)  Prescale Counter Register */
X  volatile uint32_t PC;                          
N  __IO uint32_t MCR;                        /*!< Offset: 0x014 (R/W)  Match Control Register */
X  volatile uint32_t MCR;                         
N  __IO uint32_t MR0;                        /*!< Offset: 0x018 (R/W)  Match Register 0 */
X  volatile uint32_t MR0;                         
N  __IO uint32_t MR1;                        /*!< Offset: 0x01C (R/W)  Match Register 1 */
X  volatile uint32_t MR1;                         
N  __IO uint32_t MR2;                        /*!< Offset: 0x020 (R/W)  Match Register 2 */
X  volatile uint32_t MR2;                         
N  __IO uint32_t MR3;                        /*!< Offset: 0x024 (R/W)  Match Register 3 */
X  volatile uint32_t MR3;                         
N  __IO uint32_t CCR;                        /*!< Offset: 0x028 (R/W)  Capture Control Register */
X  volatile uint32_t CCR;                         
N  __I  uint32_t CR0;                        /*!< Offset: 0x02C (R/ )  Capture Register 0 */
X  volatile const  uint32_t CR0;                         
N  __I  uint32_t CR1;                        /*!< Offset: 0x030 (R/ )  Capture Register 1 */
X  volatile const  uint32_t CR1;                         
N  __I  uint32_t CR2;                        /*!< Offset: 0x034 (R/ )  Capture Register 2 */
X  volatile const  uint32_t CR2;                         
N  __I  uint32_t CR3;                        /*!< Offset: 0x038 (R/ )  Capture Register 3 */
X  volatile const  uint32_t CR3;                         
N       uint32_t RESERVED0;
N  __IO uint32_t MR4;                        /*!< Offset: 0x040 (R/W)  Match Register 4 */
X  volatile uint32_t MR4;                         
N  __IO uint32_t MR5;                        /*!< Offset: 0x044 (R/W)  Match Register 5 */
X  volatile uint32_t MR5;                         
N  __IO uint32_t MR6;                        /*!< Offset: 0x048 (R/W)  Match Register 6 */
X  volatile uint32_t MR6;                         
N  __IO uint32_t PCR;                        /*!< Offset: 0x04C (R/W)  PWM Control Register */
X  volatile uint32_t PCR;                         
N  __IO uint32_t LER;                        /*!< Offset: 0x050 (R/W)  Load Enable Register */
X  volatile uint32_t LER;                         
N       uint32_t RESERVED1[7];
N  __IO uint32_t CTCR;                       /*!< Offset: 0x070 (R/W)  Count Control Register */
X  volatile uint32_t CTCR;                        
N} LPC_PWM_TypeDef;
N
N/*------------- Universal Asynchronous Receiver Transmitter (UART) -----------*/
N/** @brief  Universal Asynchronous Receiver Transmitter (UART) register structure definition */
Ntypedef struct
N{
N  union {
N  __I  uint32_t RBR;                   /*!< Offset: 0x000 Receiver Buffer  Register (R/ ) */
X  volatile const  uint32_t RBR;                    
N  __O  uint32_t THR;                   /*!< Offset: 0x000 Transmit Holding Register ( /W) */
X  volatile  uint32_t THR;                    
N  __IO uint32_t DLL;                   /*!< Offset: 0x000 Divisor Latch LSB (R/W) */
X  volatile uint32_t DLL;                    
N  };
N  union {
N  __IO uint32_t DLM;                   /*!< Offset: 0x004 Divisor Latch MSB (R/W) */
X  volatile uint32_t DLM;                    
N  __IO uint32_t IER;                   /*!< Offset: 0x004 Interrupt Enable Register (R/W) */
X  volatile uint32_t IER;                    
N  };
N  union {
N  __I  uint32_t IIR;                   /*!< Offset: 0x008 Interrupt ID Register (R/ ) */
X  volatile const  uint32_t IIR;                    
N  __O  uint32_t FCR;                   /*!< Offset: 0x008 FIFO Control Register ( /W) */
X  volatile  uint32_t FCR;                    
N  };
N  __IO uint32_t LCR;                   /*!< Offset: 0x00C Line Control Register (R/W) */
X  volatile uint32_t LCR;                    
N       uint32_t RESERVED0;
N  __I  uint32_t LSR;                   /*!< Offset: 0x014 Line Status Register (R/ ) */
X  volatile const  uint32_t LSR;                    
N       uint32_t RESERVED1;
N  __IO uint32_t SCR;                   /*!< Offset: 0x01C Scratch Pad Register (R/W) */
X  volatile uint32_t SCR;                    
N  __IO uint32_t ACR;                   /*!< Offset: 0x020 Auto-baud Control Register (R/W) */
X  volatile uint32_t ACR;                    
N  __IO uint32_t ICR;                   /*!< Offset: 0x024 IrDA Control Register (R/W) */
X  volatile uint32_t ICR;                    
N  __IO uint32_t FDR;                   /*!< Offset: 0x028 Fractional Divider Register (R/W) */
X  volatile uint32_t FDR;                    
N       uint32_t RESERVED2;
N  __IO uint32_t TER;                   /*!< Offset: 0x030 Transmit Enable Register (R/W) */
X  volatile uint32_t TER;                    
N} LPC_UART_TypeDef;
N
N/** @brief  Universal Asynchronous Receiver Transmitter 0 (UART0) register structure definition */
Ntypedef struct
N{
N  union {
N  __I  uint32_t  RBR;                   /*!< Offset: 0x000 Receiver Buffer  Register (R/ ) */
X  volatile const  uint32_t  RBR;                    
N  __O  uint32_t  THR;                   /*!< Offset: 0x000 Transmit Holding Register ( /W) */
X  volatile  uint32_t  THR;                    
N  __IO uint32_t  DLL;                   /*!< Offset: 0x000 Divisor Latch LSB (R/W) */
X  volatile uint32_t  DLL;                    
N  };
N  union {
N  __IO uint32_t  DLM;                   /*!< Offset: 0x004 Divisor Latch MSB (R/W) */
X  volatile uint32_t  DLM;                    
N  __IO uint32_t  IER;                   /*!< Offset: 0x000 Interrupt Enable Register (R/W) */
X  volatile uint32_t  IER;                    
N  };
N  union {
N  __I  uint32_t  IIR;                   /*!< Offset: 0x008 Interrupt ID Register (R/ ) */
X  volatile const  uint32_t  IIR;                    
N  __O  uint32_t  FCR;                   /*!< Offset: 0x008 FIFO Control Register ( /W) */
X  volatile  uint32_t  FCR;                    
N  };
N  __IO uint32_t  LCR;                   /*!< Offset: 0x00C Line Control Register (R/W) */
X  volatile uint32_t  LCR;                    
N  __IO uint32_t  MCR;                   /*!< Offset: 0x010 Modem control Register (R/W) */
X  volatile uint32_t  MCR;                    
N  __I  uint32_t  LSR;                   /*!< Offset: 0x014 Line Status Register (R/ ) */
X  volatile const  uint32_t  LSR;                    
N  __I  uint32_t  MSR;                   /*!< Offset: 0x018 Modem status Register (R/ ) */
X  volatile const  uint32_t  MSR;                    
N  __IO uint32_t  SCR;                   /*!< Offset: 0x01C Scratch Pad Register (R/W) */
X  volatile uint32_t  SCR;                    
N  __IO uint32_t  ACR;                   /*!< Offset: 0x020 Auto-baud Control Register (R/W) */
X  volatile uint32_t  ACR;                    
N       uint32_t  RESERVED0;
N  __IO uint32_t  FDR;                   /*!< Offset: 0x028 Fractional Divider Register (R/W) */
X  volatile uint32_t  FDR;                    
N       uint32_t  RESERVED1;
N  __IO uint32_t  TER;                   /*!< Offset: 0x030 Transmit Enable Register (R/W) */
X  volatile uint32_t  TER;                    
N       uint32_t  RESERVED2[6];
N  __IO uint32_t  RS485CTRL;             /*!< Offset: 0x04C RS-485/EIA-485 Control Register (R/W) */
X  volatile uint32_t  RS485CTRL;              
N  __IO uint32_t  ADRMATCH;              /*!< Offset: 0x050 RS-485/EIA-485 address match Register (R/W) */
X  volatile uint32_t  ADRMATCH;               
N  __IO uint32_t  RS485DLY;              /*!< Offset: 0x054 RS-485/EIA-485 direction control delay Register (R/W) */
X  volatile uint32_t  RS485DLY;               
N} LPC_UART1_TypeDef;
N
N/*------------- Serial Peripheral Interface (SPI) ----------------------------*/
N/** @brief  Serial Peripheral Interface (SPI) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t SPCR;                       /*!< Offset: 0x000 SPI Control Register (R/W) */
X  volatile uint32_t SPCR;                        
N  __I  uint32_t SPSR;                       /*!< Offset: 0x004 SPI Status Register (R/) */
X  volatile const  uint32_t SPSR;                        
N  __IO uint32_t SPDR;                       /*!< Offset: 0x008 SPI Data Register (R/W) */
X  volatile uint32_t SPDR;                        
N  __IO uint32_t SPCCR;                      /*!< Offset: 0x00C SPI Clock Counter Register (R/W) */
X  volatile uint32_t SPCCR;                       
N       uint32_t RESERVED0[3];
N  __IO uint32_t SPINT;                      /*!< Offset: 0x01C SPI Interrupt Flag Register (R/W) */
X  volatile uint32_t SPINT;                       
N} LPC_SPI_TypeDef;
N
N/*------------- Synchronous Serial Communication (SSP) -----------------------*/
N/** @brief  Synchronous Serial Communication (SSP) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t CR0;                        /*!< Offset: 0x000 (R/W)  Control Register 0 */
X  volatile uint32_t CR0;                         
N  __IO uint32_t CR1;                        /*!< Offset: 0x004 (R/W)  Control Register 1 */
X  volatile uint32_t CR1;                         
N  __IO uint32_t DR;                         /*!< Offset: 0x008 (R/W)  Data Register */
X  volatile uint32_t DR;                          
N  __I  uint32_t SR;                         /*!< Offset: 0x00C (R/ )  Status Register */
X  volatile const  uint32_t SR;                          
N  __IO uint32_t CPSR;                       /*!< Offset: 0x010 (R/W)  Clock Prescale Register */
X  volatile uint32_t CPSR;                        
N  __IO uint32_t IMSC;                       /*!< Offset: 0x014 (R/W)  Interrupt Mask Set and Clear Register */
X  volatile uint32_t IMSC;                        
N  __IO uint32_t RIS;                        /*!< Offset: 0x018 (R/W)  Raw Interrupt Status Register */
X  volatile uint32_t RIS;                         
N  __IO uint32_t MIS;                        /*!< Offset: 0x01C (R/W)  Masked Interrupt Status Register */
X  volatile uint32_t MIS;                         
N  __IO uint32_t ICR;                        /*!< Offset: 0x020 (R/W)  SSPICR Interrupt Clear Register */
X  volatile uint32_t ICR;                         
N  __IO uint32_t DMACR;                      /*!< Offset: 0x024 (R/W)  DMA Control Register */
X  volatile uint32_t DMACR;                       
N} LPC_SSP_TypeDef;
N
N/*------------- Inter-Integrated Circuit (I2C) -------------------------------*/
N/** @brief  Inter-Integrated Circuit (I2C) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t CONSET;                     /*!< Offset: 0x000 (R/W)  I2C Control Set Register */
X  volatile uint32_t CONSET;                      
N  __I  uint32_t STAT;                       /*!< Offset: 0x004 (R/ )  I2C Status Register */
X  volatile const  uint32_t STAT;                        
N  __IO uint32_t DAT;                        /*!< Offset: 0x008 (R/W)  I2C Data Register */
X  volatile uint32_t DAT;                         
N  __IO uint32_t ADR0;                       /*!< Offset: 0x00C (R/W)  I2C Slave Address Register 0 */
X  volatile uint32_t ADR0;                        
N  __IO uint32_t SCLH;                       /*!< Offset: 0x010 (R/W)  SCH Duty Cycle Register High Half Word */
X  volatile uint32_t SCLH;                        
N  __IO uint32_t SCLL;                       /*!< Offset: 0x014 (R/W)  SCL Duty Cycle Register Low Half Word */
X  volatile uint32_t SCLL;                        
N  __O  uint32_t CONCLR;                     /*!< Offset: 0x018 (R/W)  I2C Control Clear Register */
X  volatile  uint32_t CONCLR;                      
N  __IO uint32_t MMCTRL;                     /*!< Offset: 0x01C (R/W)  Monitor mode control register */
X  volatile uint32_t MMCTRL;                      
N  __IO uint32_t ADR1;                       /*!< Offset: 0x020 (R/W)  I2C Slave Address Register 1 */
X  volatile uint32_t ADR1;                        
N  __IO uint32_t ADR2;                       /*!< Offset: 0x024 (R/W)  I2C Slave Address Register 2 */
X  volatile uint32_t ADR2;                        
N  __IO uint32_t ADR3;                       /*!< Offset: 0x028 (R/W)  I2C Slave Address Register 3 */
X  volatile uint32_t ADR3;                        
N  __I  uint32_t DATA_BUFFER;                /*!< Offset: 0x02C (R/ )  Data buffer Register */
X  volatile const  uint32_t DATA_BUFFER;                 
N  __IO uint32_t MASK0;                      /*!< Offset: 0x030 (R/W)  I2C Slave address mask register 0 */
X  volatile uint32_t MASK0;                       
N  __IO uint32_t MASK1;                      /*!< Offset: 0x034 (R/W)  I2C Slave address mask register 1 */
X  volatile uint32_t MASK1;                       
N  __IO uint32_t MASK2;                      /*!< Offset: 0x038 (R/W)  I2C Slave address mask register 2 */
X  volatile uint32_t MASK2;                       
N  __IO uint32_t MASK3;                      /*!< Offset: 0x03C (R/W)  I2C Slave address mask register 3 */
X  volatile uint32_t MASK3;                       
N} LPC_I2C_TypeDef;
N
N/*------------- Inter IC Sound (I2S) -----------------------------------------*/
N/** @brief  Inter IC Sound (I2S) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t DAO;                        /*!< Offset: 0x000 (R/W)  Digital Audio Output Register */
X  volatile uint32_t DAO;                         
N  __IO uint32_t DAI;                        /*!< Offset: 0x004 (R/W)  Digital Audio Input Register */
X  volatile uint32_t DAI;                         
N  __O  uint32_t TXFIFO;                     /*!< Offset: 0x008 ( /W)  Transmit FIFO */
X  volatile  uint32_t TXFIFO;                      
N  __I  uint32_t RXFIFO;                     /*!< Offset: 0x00C (R/ )  Receive FIFO */
X  volatile const  uint32_t RXFIFO;                      
N  __I  uint32_t STATE;                      /*!< Offset: 0x010 (R/W)  Status Feedback Register */
X  volatile const  uint32_t STATE;                       
N  __IO uint32_t DMA1;                       /*!< Offset: 0x014 (R/W)  DMA Configuration Register 1 */
X  volatile uint32_t DMA1;                        
N  __IO uint32_t DMA2;                       /*!< Offset: 0x018 (R/W)  DMA Configuration Register 2 */
X  volatile uint32_t DMA2;                        
N  __IO uint32_t IRQ;                        /*!< Offset: 0x01C (R/W)  Interrupt Request Control Register */
X  volatile uint32_t IRQ;                         
N  __IO uint32_t TXRATE;                     /*!< Offset: 0x020 (R/W)  Transmit reference clock divider Register */
X  volatile uint32_t TXRATE;                      
N  __IO uint32_t RXRATE;                     /*!< Offset: 0x024 (R/W)  Receive reference clock divider Register */
X  volatile uint32_t RXRATE;                      
N  __IO uint32_t TXBITRATE;                  /*!< Offset: 0x028 (R/W)  Transmit bit rate divider Register */
X  volatile uint32_t TXBITRATE;                   
N  __IO uint32_t RXBITRATE;                  /*!< Offset: 0x02C (R/W)  Receive bit rate divider Register */
X  volatile uint32_t RXBITRATE;                   
N  __IO uint32_t TXMODE;                     /*!< Offset: 0x030 (R/W)  Transmit mode control Register */
X  volatile uint32_t TXMODE;                      
N  __IO uint32_t RXMODE;                     /*!< Offset: 0x034 (R/W)  Receive mode control Register */
X  volatile uint32_t RXMODE;                      
N} LPC_I2S_TypeDef;
N
N/*------------- Repetitive Interrupt Timer (RIT) -----------------------------*/
N/** @brief  Repetitive Interrupt Timer (RIT) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t RICOMPVAL;
X  volatile uint32_t RICOMPVAL;
N  __IO uint32_t RIMASK;
X  volatile uint32_t RIMASK;
N  __IO uint32_t RICTRL;
X  volatile uint32_t RICTRL;
N  __IO uint32_t RICOUNTER;
X  volatile uint32_t RICOUNTER;
N} LPC_RIT_TypeDef;
N
N/*------------- Real-Time Clock (RTC) ----------------------------------------*/
N/** @brief  Real-Time Clock (RTC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t ILR;                        /*!< Offset: 0x000 (R/W)  Interrupt Location Register */
X  volatile uint32_t ILR;                         
N       uint32_t RESERVED0;				    
N  __IO uint32_t CCR;                        /*!< Offset: 0x008 (R/W)  Clock Control Register */
X  volatile uint32_t CCR;                         
N  __IO uint32_t CIIR;                       /*!< Offset: 0x00C (R/W)  Counter Increment Interrupt Register */
X  volatile uint32_t CIIR;                        
N  __IO uint32_t AMR;                        /*!< Offset: 0x010 (R/W)  Alarm Mask Register */
X  volatile uint32_t AMR;                         
N  __I  uint32_t CTIME0;                     /*!< Offset: 0x014 (R/ )  Consolidated Time Register 0 */
X  volatile const  uint32_t CTIME0;                      
N  __I  uint32_t CTIME1;                     /*!< Offset: 0x018 (R/ )  Consolidated Time Register 1 */
X  volatile const  uint32_t CTIME1;                      
N  __I  uint32_t CTIME2;                     /*!< Offset: 0x01C (R/ )  Consolidated Time Register 2 */
X  volatile const  uint32_t CTIME2;                      
N  __IO uint32_t SEC;                        /*!< Offset: 0x020 (R/W)  Seconds Counter Register */
X  volatile uint32_t SEC;                         
N  __IO uint32_t MIN;                        /*!< Offset: 0x024 (R/W)  Minutes Register */
X  volatile uint32_t MIN;                         
N  __IO uint32_t HOUR;                       /*!< Offset: 0x028 (R/W)  Hours Register */
X  volatile uint32_t HOUR;                        
N  __IO uint32_t DOM;                        /*!< Offset: 0x02C (R/W)  Day of Month Register */
X  volatile uint32_t DOM;                         
N  __IO uint32_t DOW;                        /*!< Offset: 0x030 (R/W)  Day of Week Register */
X  volatile uint32_t DOW;                         
N  __IO uint32_t DOY;                        /*!< Offset: 0x034 (R/W)  Day of Year Register */
X  volatile uint32_t DOY;                         
N  __IO uint32_t MONTH;                      /*!< Offset: 0x038 (R/W)  Months Register */
X  volatile uint32_t MONTH;                       
N  __IO uint32_t YEAR;                       /*!< Offset: 0x03C (R/W)  Years Register */
X  volatile uint32_t YEAR;                        
N  __IO uint32_t CALIBRATION;                /*!< Offset: 0x040 (R/W)  Calibration Value Register */
X  volatile uint32_t CALIBRATION;                 
N  __IO uint32_t GPREG0;                     /*!< Offset: 0x044 (R/W)  General Purpose Register 0 */
X  volatile uint32_t GPREG0;                      
N  __IO uint32_t GPREG1;                     /*!< Offset: 0x048 (R/W)  General Purpose Register 1 */
X  volatile uint32_t GPREG1;                      
N  __IO uint32_t GPREG2;                     /*!< Offset: 0x04C (R/W)  General Purpose Register 2 */
X  volatile uint32_t GPREG2;                      
N  __IO uint32_t GPREG3;                     /*!< Offset: 0x050 (R/W)  General Purpose Register 3 */
X  volatile uint32_t GPREG3;                      
N  __IO uint32_t GPREG4;                     /*!< Offset: 0x054 (R/W)  General Purpose Register 4 */
X  volatile uint32_t GPREG4;                      
N  __IO uint32_t RTC_AUXEN;                  /*!< Offset: 0x058 (R/W)  RTC Auxiliary Enable Register */
X  volatile uint32_t RTC_AUXEN;                   
N  __IO uint32_t RTC_AUX;                    /*!< Offset: 0x05C (R/W)  RTC Auxiliary Control Register */
X  volatile uint32_t RTC_AUX;                     
N  __IO uint32_t ALSEC;                      /*!< Offset: 0x060 (R/W)  Alarm value for Seconds */
X  volatile uint32_t ALSEC;                       
N  __IO uint32_t ALMIN;                      /*!< Offset: 0x064 (R/W)  Alarm value for Minutes */
X  volatile uint32_t ALMIN;                       
N  __IO uint32_t ALHOUR;                     /*!< Offset: 0x068 (R/W)  Alarm value for Hours */
X  volatile uint32_t ALHOUR;                      
N  __IO uint32_t ALDOM;                      /*!< Offset: 0x06C (R/W)  Alarm value for Day of Month */
X  volatile uint32_t ALDOM;                       
N  __IO uint32_t ALDOW;                      /*!< Offset: 0x070 (R/W)  Alarm value for Day of Week */
X  volatile uint32_t ALDOW;                       
N  __IO uint32_t ALDOY;                      /*!< Offset: 0x074 (R/W)  Alarm value for Day of Year */
X  volatile uint32_t ALDOY;                       
N  __IO uint32_t ALMON;                      /*!< Offset: 0x078 (R/W)  Alarm value for Months */
X  volatile uint32_t ALMON;                       
N  __IO uint32_t ALYEAR;                     /*!< Offset: 0x07C (R/W)  Alarm value for Year */
X  volatile uint32_t ALYEAR;                      
N} LPC_RTC_TypeDef;
N
N/*------------- Watchdog Timer (WDT) -----------------------------------------*/
N/** @brief  Watchdog Timer (WDT) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t MOD;                        /*!< Offset: 0x000 (R/W)  Watchdog mode Register */
X  volatile uint32_t MOD;                         
N  __IO uint32_t TC;                         /*!< Offset: 0x004 (R/W)  Watchdog timer constant Register */
X  volatile uint32_t TC;                          
N  __O  uint32_t FEED;                       /*!< Offset: 0x008 ( /W)  Watchdog feed sequence Register */
X  volatile  uint32_t FEED;                        
N  __I  uint32_t TV;                         /*!< Offset: 0x00C (R/ )  Watchdog timer value Register */
X  volatile const  uint32_t TV;                          
N  __IO uint32_t WDCLKSEL;
X  volatile uint32_t WDCLKSEL;
N} LPC_WDT_TypeDef;
N
N/*------------- Analog-to-Digital Converter (ADC) ----------------------------*/
N/** @brief  Analog-to-Digital Converter (ADC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t CR;                         /*!< Offset: 0x000 (R/W)  A/D Control Register */
X  volatile uint32_t CR;                          
N  __IO uint32_t GDR;                        /*!< Offset: 0x004 (R/W)  A/D Global Data Register */
X  volatile uint32_t GDR;                         
N       uint32_t RESERVED0;
N  __IO uint32_t INTEN;                      /*!< Offset: 0x00C (R/W)  A/D Interrupt Enable Register */
X  volatile uint32_t INTEN;                       
N  __I  uint32_t DR[8];                      /*!< Offset: 0x010 (R/ )  A/D Channel # Data Register */
X  volatile const  uint32_t DR[8];                       
N  __I  uint32_t STAT;                       /*!< Offset: 0x030 (R/ )  A/D Status Register */
X  volatile const  uint32_t STAT;                        
N  __IO uint32_t ADTRM;                      /*!< Offset: 0x034 (R/W)  ADC trim Register */
X  volatile uint32_t ADTRM;                       
N	__IO uint32_t ADCR;
X	volatile uint32_t ADCR;
N  __IO uint32_t ADGDR;
X  volatile uint32_t ADGDR;
N  __IO uint32_t ADINTEN;
X  volatile uint32_t ADINTEN;
N  __I  uint32_t ADDR0;
X  volatile const  uint32_t ADDR0;
N  __I  uint32_t ADDR1;
X  volatile const  uint32_t ADDR1;
N  __I  uint32_t ADDR2;
X  volatile const  uint32_t ADDR2;
N  __I  uint32_t ADDR3;
X  volatile const  uint32_t ADDR3;
N  __I  uint32_t ADDR4;
X  volatile const  uint32_t ADDR4;
N  __I  uint32_t ADDR5;
X  volatile const  uint32_t ADDR5;
N  __I  uint32_t ADDR6;
X  volatile const  uint32_t ADDR6;
N  __I  uint32_t ADDR7;
X  volatile const  uint32_t ADDR7;
N  __I  uint32_t ADSTAT;
X  volatile const  uint32_t ADSTAT;
N} LPC_ADC_TypeDef;
N
N/*------------- Digital-to-Analog Converter (DAC) ----------------------------*/
N/** @brief  Digital-to-Analog Converter (DAC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t CR;                         /*!< Offset: 0x000 (R/W)  D/A Converter Register */
X  volatile uint32_t CR;                          
N  __IO uint32_t CTRL;                       /*!< Offset: 0x004 (R/W)  DAC Control register */
X  volatile uint32_t CTRL;                        
N  __IO uint32_t CNTVAL;                     /*!< Offset: 0x008 (R/W)  DAC Counter Value Register */
X  volatile uint32_t CNTVAL;                      
N	 __IO uint32_t DACR;
X	 volatile uint32_t DACR;
N  __IO uint32_t DACCTRL;
X  volatile uint32_t DACCTRL;
N  __IO uint16_t DACCNTVAL;
X  volatile uint16_t DACCNTVAL;
N} LPC_DAC_TypeDef;
N
N
N/*------------- Motor Control Pulse-Width Modulation (MCPWM) -----------------*/
N/** @brief  Motor Control Pulse-Width Modulation (MCPWM) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t CON;                        /*!< Offset: 0x000 (R/ )  PWM Control read address Register */
X  volatile const  uint32_t CON;                         
N  __O  uint32_t CON_SET;                    /*!< Offset: 0x004 ( /W)  PWM Control set address Register */
X  volatile  uint32_t CON_SET;                     
N  __O  uint32_t CON_CLR;                    /*!< Offset: 0x008 ( /W)  PWM Control clear address Register */
X  volatile  uint32_t CON_CLR;                     
N  __I  uint32_t CAPCON;                     /*!< Offset: 0x00C (R/ )  Capture Control read address Register */
X  volatile const  uint32_t CAPCON;                      
N  __O  uint32_t CAPCON_SET;                 /*!< Offset: 0x010 ( /W)  Capture Control set address Register */
X  volatile  uint32_t CAPCON_SET;                  
N  __O  uint32_t CAPCON_CLR;                 /*!< Offset: 0x014 ( /W)  Event Control clear address Register */
X  volatile  uint32_t CAPCON_CLR;                  
N  __IO uint32_t TC0;                        /*!< Offset: 0x018 (R/W)  Timer Counter Register, channel 0 */
X  volatile uint32_t TC0;                         
N  __IO uint32_t TC1;                        /*!< Offset: 0x01C (R/W)  Timer Counter Register, channel 1 */
X  volatile uint32_t TC1;                         
N  __IO uint32_t TC2;                        /*!< Offset: 0x020 (R/W)  Timer Counter Register, channel 2 */
X  volatile uint32_t TC2;                         
N  __IO uint32_t LIM0;                       /*!< Offset: 0x024 (R/W)  Limit Register, channel 0 */
X  volatile uint32_t LIM0;                        
N  __IO uint32_t LIM1;                       /*!< Offset: 0x028 (R/W)  Limit Register, channel 1 */
X  volatile uint32_t LIM1;                        
N  __IO uint32_t LIM2;                       /*!< Offset: 0x02C (R/W)  Limit Register, channel 2 */
X  volatile uint32_t LIM2;                        
N  __IO uint32_t MAT0;                       /*!< Offset: 0x030 (R/W)  Match Register, channel 0 */
X  volatile uint32_t MAT0;                        
N  __IO uint32_t MAT1;                       /*!< Offset: 0x034 (R/W)  Match Register, channel 1 */
X  volatile uint32_t MAT1;                        
N  __IO uint32_t MAT2;                       /*!< Offset: 0x038 (R/W)  Match Register, channel 2 */
X  volatile uint32_t MAT2;                        
N  __IO uint32_t DT;                         /*!< Offset: 0x03C (R/W)  Dead time Register */
X  volatile uint32_t DT;                          
N  __IO uint32_t CP;                         /*!< Offset: 0x040 (R/W)  Commutation Pattern Register */
X  volatile uint32_t CP;                          
N  __IO uint32_t CAP0;                       /*!< Offset: 0x044 (R/W)  Capture Register, channel 0 */
X  volatile uint32_t CAP0;                        
N  __IO uint32_t CAP1;                       /*!< Offset: 0x048 (R/W)  Capture Register, channel 1 */
X  volatile uint32_t CAP1;                        
N  __IO uint32_t CAP2;                       /*!< Offset: 0x04C (R/W)  Capture Register, channel 2 */
X  volatile uint32_t CAP2;                        
N  __I  uint32_t INTEN;                      /*!< Offset: 0x050 (R/ )  Interrupt Enable read Register */
X  volatile const  uint32_t INTEN;                       
N  __O  uint32_t INTEN_SET;                  /*!< Offset: 0x054 ( /W)  Interrupt Enable set address Register */
X  volatile  uint32_t INTEN_SET;                   
N  __O  uint32_t INTEN_CLR;                  /*!< Offset: 0x058 ( /W)  Interrupt Enable clear address Register */
X  volatile  uint32_t INTEN_CLR;                   
N  __I  uint32_t CNTCON;                     /*!< Offset: 0x05C (R/ )  Count Control read address Register */
X  volatile const  uint32_t CNTCON;                      
N  __O  uint32_t CNTCON_SET;                 /*!< Offset: 0x060 ( /W)  Count Control set address Register */
X  volatile  uint32_t CNTCON_SET;                  
N  __O  uint32_t CNTCON_CLR;                 /*!< Offset: 0x064 ( /W)  Count Control clear address Register */
X  volatile  uint32_t CNTCON_CLR;                  
N  __I  uint32_t INTF;                       /*!< Offset: 0x068 (R/ )  Interrupt flags read address Register */
X  volatile const  uint32_t INTF;                        
N  __O  uint32_t INTF_SET;                   /*!< Offset: 0x06C ( /W)  Interrupt flags set address Register */
X  volatile  uint32_t INTF_SET;                    
N  __O  uint32_t INTF_CLR;                   /*!< Offset: 0x070 ( /W)  Interrupt flags clear address Register */
X  volatile  uint32_t INTF_CLR;                    
N  __O  uint32_t CAP_CLR;                    /*!< Offset: 0x074 ( /W)  Capture clear address Register */
X  volatile  uint32_t CAP_CLR;                     
N} LPC_MCPWM_TypeDef;
N
N/*------------- Quadrature Encoder Interface (QEI) ---------------------------*/
N/** @brief  Quadrature Encoder Interface (QEI) register structure definition */
Ntypedef struct
N{
N  __O  uint32_t CON;                        /*!< Offset: 0x000 ( /W)  Control Register */
X  volatile  uint32_t CON;                         
N  __I  uint32_t STAT;                       /*!< Offset: 0x004 (R/ )  Encoder Status Register */
X  volatile const  uint32_t STAT;                        
N  __IO uint32_t CONF;                       /*!< Offset: 0x008 (R/W)  Configuration Register */
X  volatile uint32_t CONF;                        
N  __I  uint32_t POS;                        /*!< Offset: 0x00C (R/ )  Position Register */
X  volatile const  uint32_t POS;                         
N  __IO uint32_t MAXPOS;                     /*!< Offset: 0x010 (R/W)  Maximum position Register */
X  volatile uint32_t MAXPOS;                      
N  __IO uint32_t CMPOS0;                     /*!< Offset: 0x014 (R/W)  Position compare Register 0 */
X  volatile uint32_t CMPOS0;                      
N  __IO uint32_t CMPOS1;                     /*!< Offset: 0x018 (R/W)  Position compare Register 1 */
X  volatile uint32_t CMPOS1;                      
N  __IO uint32_t CMPOS2;                     /*!< Offset: 0x01C (R/W)  Position compare Register 2 */
X  volatile uint32_t CMPOS2;                      
N  __I  uint32_t INXCNT;                     /*!< Offset: 0x020 (R/ )  Index count Register */
X  volatile const  uint32_t INXCNT;                      
N  __IO uint32_t INXCMP0;                    /*!< Offset: 0x024 (R/W)  Index compare Register 0 */
X  volatile uint32_t INXCMP0;                     
N  __IO uint32_t LOAD;                       /*!< Offset: 0x028 (R/W)  Velocity timer reload Register */
X  volatile uint32_t LOAD;                        
N  __I  uint32_t TIME;                       /*!< Offset: 0x02C (R/ )  Velocity timer Register */
X  volatile const  uint32_t TIME;                        
N  __I  uint32_t VEL;                        /*!< Offset: 0x030 (R/ )  Velocity counter Register */
X  volatile const  uint32_t VEL;                         
N  __I  uint32_t CAP;                        /*!< Offset: 0x034 (R/ )  Velocity capture Register */
X  volatile const  uint32_t CAP;                         
N  __IO uint32_t VELCOMP;                    /*!< Offset: 0x038 (R/W)  Velocity compare Register */
X  volatile uint32_t VELCOMP;                     
N  __IO uint32_t FILTER;
X  volatile uint32_t FILTER;
N       uint32_t RESERVED0[998];
N  __O  uint32_t IEC;                        /*!< Offset: 0xFD8 ( /W)  Interrupt enable clear Register */
X  volatile  uint32_t IEC;                         
N  __O  uint32_t IES;                        /*!< Offset: 0xFDC ( /W)  Interrupt enable set Register */
X  volatile  uint32_t IES;                         
N  __I  uint32_t INTSTAT;                    /*!< Offset: 0xFE0 (R/ )  Interrupt status Register */
X  volatile const  uint32_t INTSTAT;                     
N  __I  uint32_t IE;                         /*!< Offset: 0xFE4 (R/ )  Interrupt enable Register */
X  volatile const  uint32_t IE;                          
N  __O  uint32_t CLR;                        /*!< Offset: 0xFE8 ( /W)  Interrupt status clear Register */
X  volatile  uint32_t CLR;                         
N  __O  uint32_t SET;                        /*!< Offset: 0xFEC ( /W)  Interrupt status set Register */
X  volatile  uint32_t SET;                         
N} LPC_QEI_TypeDef;
N
N/*------------- Controller Area Network (CAN) --------------------------------*/
N/** @brief  Controller Area Network Acceptance Filter RAM (CANAF_RAM)structure definition */
Ntypedef struct
N{
N  __IO uint32_t mask[512];                  /*!< Offset: 0x000 (R/W)  Acceptance Filter RAM */
X  volatile uint32_t mask[512];                   
N} LPC_CANAF_RAM_TypeDef;
N
N/** @brief  Controller Area Network Acceptance Filter(CANAF) register structure definition */
Ntypedef struct                          /* Acceptance Filter Registers        */
N{
N  __IO uint32_t AFMR;                       /*!< Offset: 0x000 (R/W)  Acceptance Filter Register */
X  volatile uint32_t AFMR;                        
N  __IO uint32_t SFF_sa;                     /*!< Offset: 0x004 (R/W)  Standard Frame Individual Start Address Register */
X  volatile uint32_t SFF_sa;                      
N  __IO uint32_t SFF_GRP_sa;                 /*!< Offset: 0x008 (R/W)  Standard Frame Group Start Address Register */
X  volatile uint32_t SFF_GRP_sa;                  
N  __IO uint32_t EFF_sa;                     /*!< Offset: 0x00C (R/W)  Extended Frame Start Address Register */
X  volatile uint32_t EFF_sa;                      
N  __IO uint32_t EFF_GRP_sa;                 /*!< Offset: 0x010 (R/W)  Extended Frame Group Start Address Register */
X  volatile uint32_t EFF_GRP_sa;                  
N  __IO uint32_t ENDofTable;                 /*!< Offset: 0x014 (R/W)  End of AF Tables Register */
X  volatile uint32_t ENDofTable;                  
N  __I  uint32_t LUTerrAd;                   /*!< Offset: 0x018 (R/ )  LUT Error Address Register */
X  volatile const  uint32_t LUTerrAd;                    
N  __I  uint32_t LUTerr;                     /*!< Offset: 0x01C (R/ )  LUT Error Register */
X  volatile const  uint32_t LUTerr;                      
N  __IO uint32_t FCANIE;                     /*!< Offset: 0x020 (R/W)  Global FullCANInterrupt Enable Register */
X  volatile uint32_t FCANIE;                      
N  __IO uint32_t FCANIC0;                    /*!< Offset: 0x024 (R/W)  FullCAN Interrupt and Capture Register 0 */
X  volatile uint32_t FCANIC0;                     
N  __IO uint32_t FCANIC1;                    /*!< Offset: 0x028 (R/W)  FullCAN Interrupt and Capture Register 1 */
X  volatile uint32_t FCANIC1;                     
N} LPC_CANAF_TypeDef;
N
N/** @brief  Controller Area Network Central (CANCR) register structure definition */
Ntypedef struct                          /* Central Registers                  */
N{
N  __I  uint32_t TxSR;                       /*!< Offset: 0x000 (R/ )  CAN Central Transmit Status Register */
X  volatile const  uint32_t TxSR;                        
N  __I  uint32_t RxSR;                       /*!< Offset: 0x004 (R/ )  CAN Central Receive Status Register */
X  volatile const  uint32_t RxSR;                        
N  __I  uint32_t MSR;                        /*!< Offset: 0x008 (R/ )  CAN Central Miscellaneous Register */
X  volatile const  uint32_t MSR;                         
N} LPC_CANCR_TypeDef;
N
N/** @brief  Controller Area Network Controller (CAN) register structure definition */
Ntypedef struct                              /* Controller Registers               */
N{
N  __IO uint32_t MOD;                        /*!< Offset: 0x000 (R/W)  CAN Mode Register */
X  volatile uint32_t MOD;                         
N  __O  uint32_t CMR;                        /*!< Offset: 0x004 ( /W)  CAN Command Register */
X  volatile  uint32_t CMR;                         
N  __IO uint32_t GSR;                        /*!< Offset: 0x008 (R/W)  CAN Global Status Register */
X  volatile uint32_t GSR;                         
N  __I  uint32_t ICR;                        /*!< Offset: 0x00C (R/ )  CAN Interrupt and Capture Register */
X  volatile const  uint32_t ICR;                         
N  __IO uint32_t IER;                        /*!< Offset: 0x010 (R/W)  CAN Interrupt Enable Register */
X  volatile uint32_t IER;                         
N  __IO uint32_t BTR;                        /*!< Offset: 0x014 (R/W)  CAN Bus Timing Register */
X  volatile uint32_t BTR;                         
N  __IO uint32_t EWL;                        /*!< Offset: 0x018 (R/W)  CAN Error Warning Limit Register */
X  volatile uint32_t EWL;                         
N  __I  uint32_t SR;                         /*!< Offset: 0x01C (R/ )  CAN Status Register */
X  volatile const  uint32_t SR;                          
N  __IO uint32_t RFS;                        /*!< Offset: 0x020 (R/W)  CAN Receive Frame Status Register */
X  volatile uint32_t RFS;                         
N  __IO uint32_t RID;                        /*!< Offset: 0x024 (R/W)  CAN Receive Identifier Register */
X  volatile uint32_t RID;                         
N  __IO uint32_t RDA;                        /*!< Offset: 0x028 (R/W)  CAN Receive Data Register A */
X  volatile uint32_t RDA;                         
N  __IO uint32_t RDB;                        /*!< Offset: 0x02C (R/W)  CAN Receive Data Register B */
X  volatile uint32_t RDB;                         
N  __IO uint32_t TFI1;                       /*!< Offset: 0x030 (R/W)  CAN Transmit Frame Information Register 1 */
X  volatile uint32_t TFI1;                        
N  __IO uint32_t TID1;                       /*!< Offset: 0x034 (R/W)  CAN Transmit Identifier Register 1 */
X  volatile uint32_t TID1;                        
N  __IO uint32_t TDA1;                       /*!< Offset: 0x038 (R/W)  CAN Transmit Data Register A 1 */
X  volatile uint32_t TDA1;                        
N  __IO uint32_t TDB1;                       /*!< Offset: 0x03C (R/W)  CAN Transmit Data Register B 1 */
X  volatile uint32_t TDB1;                        
N  __IO uint32_t TFI2;                       /*!< Offset: 0x040 (R/W)  CAN Transmit Frame Information Register 2 */
X  volatile uint32_t TFI2;                        
N  __IO uint32_t TID2;                       /*!< Offset: 0x044 (R/W)  CAN Transmit Identifier Register 2 */
X  volatile uint32_t TID2;                        
N  __IO uint32_t TDA2;                       /*!< Offset: 0x048 (R/W)  CAN Transmit Data Register A 2 */
X  volatile uint32_t TDA2;                        
N  __IO uint32_t TDB2;                       /*!< Offset: 0x04C (R/W)  CAN Transmit Data Register B 2 */
X  volatile uint32_t TDB2;                        
N  __IO uint32_t TFI3;                       /*!< Offset: 0x050 (R/W)  CAN Transmit Frame Information Register 3 */
X  volatile uint32_t TFI3;                        
N  __IO uint32_t TID3;                       /*!< Offset: 0x054 (R/W)  CAN Transmit Identifier Register 3 */
X  volatile uint32_t TID3;                        
N  __IO uint32_t TDA3;                       /*!< Offset: 0x058 (R/W)  CAN Transmit Data Register A 3 */
X  volatile uint32_t TDA3;                        
N  __IO uint32_t TDB3;                       /*!< Offset: 0x05C (R/W)  CAN Transmit Data Register B 3 */
X  volatile uint32_t TDB3;                        
N} LPC_CAN_TypeDef;
N
N/*------------- General Purpose Direct Memory Access (GPDMA) -----------------*/
N/** @brief  General Purpose Direct Memory Access (GPDMA) register structure definition */
Ntypedef struct                              /* Common Registers                   */
N{
N  __I  uint32_t IntStat;                    /*!< Offset: 0x000 (R/ )  DMA Interrupt Status Register */
X  volatile const  uint32_t IntStat;                     
N  __I  uint32_t IntTCStat;                  /*!< Offset: 0x004 (R/ )  DMA Interrupt Terminal Count Request Status Register */
X  volatile const  uint32_t IntTCStat;                   
N  __O  uint32_t IntTCClear;                 /*!< Offset: 0x008 ( /W)  DMA Interrupt Terminal Count Request Clear Register */
X  volatile  uint32_t IntTCClear;                  
N  __I  uint32_t IntErrStat;                 /*!< Offset: 0x00C (R/ )  DMA Interrupt Error Status Register */
X  volatile const  uint32_t IntErrStat;                  
N  __O  uint32_t IntErrClr;                  /*!< Offset: 0x010 ( /W)  DMA Interrupt Error Clear Register */
X  volatile  uint32_t IntErrClr;                   
N  __I  uint32_t RawIntTCStat;               /*!< Offset: 0x014 (R/ )  DMA Raw Interrupt Terminal Count Status Register */
X  volatile const  uint32_t RawIntTCStat;                
N  __I  uint32_t RawIntErrStat;              /*!< Offset: 0x018 (R/ )  DMA Raw Error Interrupt Status Register */
X  volatile const  uint32_t RawIntErrStat;               
N  __I  uint32_t EnbldChns;                  /*!< Offset: 0x01C (R/ )  DMA Enabled Channel Register */
X  volatile const  uint32_t EnbldChns;                   
N  __IO uint32_t SoftBReq;                   /*!< Offset: 0x020 (R/W)  DMA Software Burst Request Register */
X  volatile uint32_t SoftBReq;                    
N  __IO uint32_t SoftSReq;                   /*!< Offset: 0x024 (R/W)  DMA Software Single Request Register */
X  volatile uint32_t SoftSReq;                    
N  __IO uint32_t SoftLBReq;                  /*!< Offset: 0x028 (R/W)  DMA Software Last Burst Request Register */
X  volatile uint32_t SoftLBReq;                   
N  __IO uint32_t SoftLSReq;                  /*!< Offset: 0x02C (R/W)  DMA Software Last Single Request Register */
X  volatile uint32_t SoftLSReq;                   
N  __IO uint32_t Config;                     /*!< Offset: 0x030 (R/W)  DMA Configuration Register */
X  volatile uint32_t Config;                      
N  __IO uint32_t Sync;                       /*!< Offset: 0x034 (R/W)  DMA Synchronization Register */
X  volatile uint32_t Sync;                        
N} LPC_GPDMA_TypeDef;
N
N/** @brief  General Purpose Direct Memory Access Channel (GPDMACH) register structure definition */
Ntypedef struct                              /* Channel Registers                  */
N{
N  __IO uint32_t CSrcAddr;                   /*!< Offset: 0x000 (R/W)  DMA Channel # Source Address Register */
X  volatile uint32_t CSrcAddr;                    
N  __IO uint32_t CDestAddr;                  /*!< Offset: 0x004 (R/W)  DMA Channel # Destination Address Register */
X  volatile uint32_t CDestAddr;                   
N  __IO uint32_t CLLI;                       /*!< Offset: 0x008 (R/W)  DMA Channel # Linked List Item Register */
X  volatile uint32_t CLLI;                        
N  __IO uint32_t CControl;                   /*!< Offset: 0x00C (R/W)  DMA Channel # Control Register */
X  volatile uint32_t CControl;                    
N  __IO uint32_t CConfig;                    /*!< Offset: 0x010 (R/W)  DMA Channel # Configuration Register */
X  volatile uint32_t CConfig;                     
N} LPC_GPDMACH_TypeDef;
N
N/*------------- Universal Serial Bus (USB) -----------------------------------*/
N/** @brief  Universal Serial Bus (USB) register structure definition */
Ntypedef struct
N{
N  __I  uint32_t Revision;                 /*!< Offset: 0x000 (R/ )  Revision Register */
X  volatile const  uint32_t Revision;                  
N  __IO uint32_t Control;                  /*!< Offset: 0x004 (R/W)  Control Register */
X  volatile uint32_t Control;                   
N  __IO uint32_t CommandStatus;            /*!< Offset: 0x008 (R/W)  Command / Status Register */
X  volatile uint32_t CommandStatus;             
N  __IO uint32_t InterruptStatus;          /*!< Offset: 0x00C (R/W)  Interrupt Status Register */
X  volatile uint32_t InterruptStatus;           
N  __IO uint32_t InterruptEnable;          /*!< Offset: 0x010 (R/W)  Interrupt Enable Register */
X  volatile uint32_t InterruptEnable;           
N  __IO uint32_t InterruptDisable;         /*!< Offset: 0x014 (R/W)  Interrupt Disable Register */
X  volatile uint32_t InterruptDisable;          
N  __IO uint32_t HCCA;                     /*!< Offset: 0x018 (R/W)  Host Controller communication Area Register */
X  volatile uint32_t HCCA;                      
N  __I  uint32_t PeriodCurrentED;          /*!< Offset: 0x01C (R/ )   Register */
X  volatile const  uint32_t PeriodCurrentED;           
N  __IO uint32_t ControlHeadED;            /*!< Offset: 0x020 (R/W)   Register */
X  volatile uint32_t ControlHeadED;             
N  __IO uint32_t ControlCurrentED;         /*!< Offset: 0x024 (R/W)   Register */
X  volatile uint32_t ControlCurrentED;          
N  __IO uint32_t BulkHeadED;               /*!< Offset: 0x028 (R/W)   Register */
X  volatile uint32_t BulkHeadED;                
N  __IO uint32_t BulkCurrentED;            /*!< Offset: 0x02C (R/W)   Register */
X  volatile uint32_t BulkCurrentED;             
N  __I  uint32_t DoneHead;                 /*!< Offset: 0x030 (R/ )   Register */
X  volatile const  uint32_t DoneHead;                  
N  __IO uint32_t FmInterval;               /*!< Offset: 0x034 (R/W)   Register */
X  volatile uint32_t FmInterval;                
N  __I  uint32_t FmRemaining;              /*!< Offset: 0x038 (R/ )   Register */
X  volatile const  uint32_t FmRemaining;               
N  __I  uint32_t FmNumber;                 /*!< Offset: 0x03C (R/ )   Register */
X  volatile const  uint32_t FmNumber;                  
N  __IO uint32_t PeriodicStart;            /*!< Offset: 0x040 (R/W)   Register */
X  volatile uint32_t PeriodicStart;             
N  __IO uint32_t LSTreshold;               /*!< Offset: 0x044 (R/W)   Register */
X  volatile uint32_t LSTreshold;                
N  __IO uint32_t RhDescriptorA;            /*!< Offset: 0x048 (R/W)   Register */
X  volatile uint32_t RhDescriptorA;             
N  __IO uint32_t RhDescriptorB;            /*!< Offset: 0x04C (R/W)   Register */
X  volatile uint32_t RhDescriptorB;             
N  __IO uint32_t RhStatus;                 /*!< Offset: 0x050 (R/W)   Register */
X  volatile uint32_t RhStatus;                  
N  __IO uint32_t RhPortStatus1;            /*!< Offset: 0x054 (R/W)   Register */
X  volatile uint32_t RhPortStatus1;             
N  __IO uint32_t RhPortStatus2;            /*!< Offset: 0x05C (R/W)   Register */
X  volatile uint32_t RhPortStatus2;             
N       uint32_t RESERVED0[40];
N  __I  uint32_t Module_ID;                /*!< Offset: 0x0FC (R/ )  Module ID / Version Reverence ID Register */
X  volatile const  uint32_t Module_ID;                 
N                                          /* USB On-The-Go Registers            */
N  __I  uint32_t IntSt;                    /*!< Offset: 0x100 (R/ )  OTG Interrupt Status Register */
X  volatile const  uint32_t IntSt;                     
N  __IO uint32_t IntEn;                    /*!< Offset: 0x104 (R/W)  OTG Interrupt Enable Register */
X  volatile uint32_t IntEn;                     
N  __O  uint32_t IntSet;                   /*!< Offset: 0x108 ( /W)  OTG Interrupt Set Register */
X  volatile  uint32_t IntSet;                    
N  __O  uint32_t IntClr;                   /*!< Offset: 0x10C ( /W)  OTG Interrupt Clear Register */
X  volatile  uint32_t IntClr;                    
N  __IO uint32_t StCtrl;                   /*!< Offset: 0x110 (R/W)  OTG Status and Control Register */
X  volatile uint32_t StCtrl;                    
N  __IO uint32_t Tmr;                      /*!< Offset: 0x114 (R/W)  OTG Timer Register */
X  volatile uint32_t Tmr;                       
N       uint32_t RESERVED1[58];
N                                          /* USB Device Interrupt Registers     */
N  __I  uint32_t DevIntSt;                 /*!< Offset: 0x200 (R/ )  USB Device Interrupt Status Register */
X  volatile const  uint32_t DevIntSt;                  
N  __IO uint32_t DevIntEn;                 /*!< Offset: 0x204 (R/W)  USB Device Interrupt Enable Register */
X  volatile uint32_t DevIntEn;                  
N  __O  uint32_t DevIntClr;                /*!< Offset: 0x208 ( /W)  USB Device Interrupt Clear Register */
X  volatile  uint32_t DevIntClr;                 
N  __O  uint32_t DevIntSet;                /*!< Offset: 0x20C ( /W)  USB Device Interrupt Set Register */
X  volatile  uint32_t DevIntSet;                 
N                                          /* USB Device SIE Command Registers   */
N  __O  uint32_t CmdCode;                  /*!< Offset: 0x210 (R/W)  USB Command Code Register */
X  volatile  uint32_t CmdCode;                   
N  __I  uint32_t CmdData;                  /*!< Offset: 0x214 (R/W)  USB Command Data Register */
X  volatile const  uint32_t CmdData;                   
N                                          /* USB Device Transfer Registers      */
N  __I  uint32_t RxData;                   /*!< Offset: 0x218 (R/ )  USB Receive Data Register */
X  volatile const  uint32_t RxData;                    
N  __O  uint32_t TxData;                   /*!< Offset: 0x21C ( /W)  USB Transmit Data Register */
X  volatile  uint32_t TxData;                    
N  __I  uint32_t RxPLen;                   /*!< Offset: 0x220 (R/ )  USB Receive Packet Length Register */
X  volatile const  uint32_t RxPLen;                    
N  __O  uint32_t TxPLen;                   /*!< Offset: 0x224 ( /W)  USB Transmit Packet Length Register */
X  volatile  uint32_t TxPLen;                    
N  __IO uint32_t Ctrl;                     /*!< Offset: 0x228 (R/W)  USB Control Register */
X  volatile uint32_t Ctrl;                      
N  __O  uint32_t DevIntPri;                /*!< Offset: 0x22C (R/W)  USB Device Interrupt Priority Register */
X  volatile  uint32_t DevIntPri;                 
N                                          /* USB Device Endpoint Interrupt Regs */
N  __I  uint32_t EpIntSt;                  /*!< Offset: 0x230 (R/ )  USB Endpoint Interrupt Status Register */
X  volatile const  uint32_t EpIntSt;                   
N  __IO uint32_t EpIntEn;                  /*!< Offset: 0x234 (R/W)  USB Endpoint Interrupt Enable Register */
X  volatile uint32_t EpIntEn;                   
N  __O  uint32_t EpIntClr;                 /*!< Offset: 0x238 ( /W)  USB Endpoint Interrupt Clear Register */
X  volatile  uint32_t EpIntClr;                  
N  __O  uint32_t EpIntSet;                 /*!< Offset: 0x23C ( /W)  USB Endpoint Interrupt Set Register */
X  volatile  uint32_t EpIntSet;                  
N  __O  uint32_t EpIntPri;                 /*!< Offset: 0x240 ( /W)  USB Endpoint Interrupt Priority Register */
X  volatile  uint32_t EpIntPri;                  
N                                          /* USB Device Endpoint Realization Reg*/
N  __IO uint32_t ReEp;                     /*!< Offset: 0x244 (R/W)  USB Realize Endpoint Register */
X  volatile uint32_t ReEp;                      
N  __O  uint32_t EpInd;                    /*!< Offset: 0x248 ( /W)  USB Endpoint Index Register */
X  volatile  uint32_t EpInd;                     
N  __IO uint32_t MaxPSize;                 /*!< Offset: 0x24C (R/W)  USB MaxPacketSize Register */
X  volatile uint32_t MaxPSize;                  
N                                          /* USB Device DMA Registers           */
N  __I  uint32_t DMARSt;                   /*!< Offset: 0x250 (R/ )  USB DMA Request Status Register */
X  volatile const  uint32_t DMARSt;                    
N  __O  uint32_t DMARClr;                  /*!< Offset: 0x254 ( /W)  USB DMA Request Clear Register */
X  volatile  uint32_t DMARClr;                   
N  __O  uint32_t DMARSet;                  /*!< Offset: 0x258 ( /W)  USB DMA Request Set Register */
X  volatile  uint32_t DMARSet;                   
N       uint32_t RESERVED2[9];
N  __IO uint32_t UDCAH;                    /*!< Offset: 0x280 (R/W)  USB UDCA Head Register */
X  volatile uint32_t UDCAH;                     
N  __I  uint32_t EpDMASt;                  /*!< Offset: 0x284 (R/ )  USB EP DMA Status Register */
X  volatile const  uint32_t EpDMASt;                   
N  __O  uint32_t EpDMAEn;                  /*!< Offset: 0x288 ( /W)  USB EP DMA Enable Register */
X  volatile  uint32_t EpDMAEn;                   
N  __O  uint32_t EpDMADis;                 /*!< Offset: 0x28C ( /W)  USB EP DMA Disable Register */
X  volatile  uint32_t EpDMADis;                  
N  __I  uint32_t DMAIntSt;                 /*!< Offset: 0x290 (R/ )  USB DMA Interrupt Status Register */
X  volatile const  uint32_t DMAIntSt;                  
N  __IO uint32_t DMAIntEn;                 /*!< Offset: 0x294 (R/W)  USB DMA Interrupt Enable Register */
X  volatile uint32_t DMAIntEn;                  
N       uint32_t RESERVED3[2];
N  __I  uint32_t EoTIntSt;                 /*!< Offset: 0x2A0 (R/ )  USB End of Transfer Interrupt Status Register */
X  volatile const  uint32_t EoTIntSt;                  
N  __O  uint32_t EoTIntClr;                /*!< Offset: 0x2A4 ( /W)  USB End of Transfer Interrupt Clear Register */
X  volatile  uint32_t EoTIntClr;                 
N  __O  uint32_t EoTIntSet;                /*!< Offset: 0x2A8 ( /W)  USB End of Transfer Interrupt Set Register */
X  volatile  uint32_t EoTIntSet;                 
N  __I  uint32_t NDDRIntSt;                /*!< Offset: 0x2AC (R/ )  USB New DD Request Interrupt Status Register */
X  volatile const  uint32_t NDDRIntSt;                 
N  __O  uint32_t NDDRIntClr;               /*!< Offset: 0x2B0 ( /W)  USB New DD Request Interrupt Clear Register */
X  volatile  uint32_t NDDRIntClr;                
N  __O  uint32_t NDDRIntSet;               /*!< Offset: 0x2B4 ( /W)  USB New DD Request Interrupt Set Register */
X  volatile  uint32_t NDDRIntSet;                
N  __I  uint32_t SysErrIntSt;              /*!< Offset: 0x2B8 (R/ )  USB System Error Interrupt Status Register */
X  volatile const  uint32_t SysErrIntSt;               
N  __O  uint32_t SysErrIntClr;             /*!< Offset: 0x2BC ( /W)  USB System Error Interrupt Clear Register */
X  volatile  uint32_t SysErrIntClr;              
N  __O  uint32_t SysErrIntSet;             /*!< Offset: 0x2C0 ( /W)  USB System Error Interrupt Set Register */
X  volatile  uint32_t SysErrIntSet;              
N       uint32_t RESERVED4[15];
N                                          /* USB OTG I2C Registers              */
N  union {
N  __I  uint32_t I2C_RX;                   /*!< Offset: 0x300 (R/ )  OTG I2C Receive Register */
X  volatile const  uint32_t I2C_RX;                    
N  __O  uint32_t I2C_TX;                   /*!< Offset: 0x300 ( /W)  OTG I2C Transmit Register */
X  volatile  uint32_t I2C_TX;                    
N  };
N  __I  uint32_t I2C_STS;                  /*!< Offset: 0x304 (R/ )  OTG I2C Status Register */
X  volatile const  uint32_t I2C_STS;                   
N  __IO uint32_t I2C_CTL;                  /*!< Offset: 0x308 (R/W)  OTG I2C Control Register */
X  volatile uint32_t I2C_CTL;                   
N  __IO uint32_t I2C_CLKHI;                /*!< Offset: 0x30C (R/W)  OTG I2C Clock High Register */
X  volatile uint32_t I2C_CLKHI;                 
N  __O  uint32_t I2C_CLKLO;                /*!< Offset: 0x310 ( /W)  OTG I2C Clock Low Register */
X  volatile  uint32_t I2C_CLKLO;                 
N       uint32_t RESERVED5[824];
N                                          /* USB Clock Control Registers        */
N  union {
N  __IO uint32_t USBClkCtrl;               /*!< Offset: 0xFF4 (R/W)  OTG clock controller Register */
X  volatile uint32_t USBClkCtrl;                
N  __IO uint32_t OTGClkCtrl;               /*!< Offset: 0xFF4 (R/W)  USB clock controller Register */
X  volatile uint32_t OTGClkCtrl;                
N  };
N  union {
N  __I  uint32_t USBClkSt;                 /*!< Offset: 0xFF8 (R/ )  OTG clock status Register */
X  volatile const  uint32_t USBClkSt;                  
N  __I  uint32_t OTGClkSt;                 /*!< Offset: 0xFF8 (R/ )  USB clock status Register */
X  volatile const  uint32_t OTGClkSt;                  
N  };
N} LPC_USB_TypeDef;
N
N/*------------- Ethernet Media Access Controller (EMAC) ----------------------*/
N/** @brief  Ethernet Media Access Controller (EMAC) register structure definition */
Ntypedef struct
N{
N  __IO uint32_t MAC1;                       /*!< Offset: 0x000 (R/W)  MAC Configuration Register 1 */
X  volatile uint32_t MAC1;                        
N  __IO uint32_t MAC2;                       /*!< Offset: 0x004 (R/W)  MAC Configuration Register 2 */
X  volatile uint32_t MAC2;                        
N  __IO uint32_t IPGT;                       /*!< Offset: 0x008 (R/W)  Back-to-Back Inter-Packet-Gap Register */
X  volatile uint32_t IPGT;                        
N  __IO uint32_t IPGR;                       /*!< Offset: 0x00C (R/W)  Non Back-to-Back Inter-Packet-Gap Register */
X  volatile uint32_t IPGR;                        
N  __IO uint32_t CLRT;                       /*!< Offset: 0x010 (R/W)  Collision Window / Retry Register */
X  volatile uint32_t CLRT;                        
N  __IO uint32_t MAXF;                       /*!< Offset: 0x014 (R/W)  Maximum Frame Register */
X  volatile uint32_t MAXF;                        
N  __IO uint32_t SUPP;                       /*!< Offset: 0x018 (R/W)  PHY Support Register */
X  volatile uint32_t SUPP;                        
N  __IO uint32_t TEST;                       /*!< Offset: 0x01C (R/W)  Test Register */
X  volatile uint32_t TEST;                        
N  __IO uint32_t MCFG;                       /*!< Offset: 0x020 (R/W)  MII Mgmt Configuration Register */
X  volatile uint32_t MCFG;                        
N  __IO uint32_t MCMD;                       /*!< Offset: 0x024 (R/W)  MII Mgmt Command Register */
X  volatile uint32_t MCMD;                        
N  __IO uint32_t MADR;                       /*!< Offset: 0x028 (R/W)  MII Mgmt Address Register */
X  volatile uint32_t MADR;                        
N  __O  uint32_t MWTD;                       /*!< Offset: 0x02C ( /W)  MII Mgmt Write Data Register */
X  volatile  uint32_t MWTD;                        
N  __I  uint32_t MRDD;                       /*!< Offset: 0x030 (R/ )  MII Mgmt Read Data Register */
X  volatile const  uint32_t MRDD;                        
N  __I  uint32_t MIND;                       /*!< Offset: 0x034 (R/ )  MII Mgmt Indicators Register */
X  volatile const  uint32_t MIND;                        
N       uint32_t RESERVED0[2];
N  __IO uint32_t SA0;                        /*!< Offset: 0x040 (R/W)  Station Address 0 Register */
X  volatile uint32_t SA0;                         
N  __IO uint32_t SA1;                        /*!< Offset: 0x044 (R/W)  Station Address 1 Register */
X  volatile uint32_t SA1;                         
N  __IO uint32_t SA2;                        /*!< Offset: 0x048 (R/W)  Station Address 2 Register */
X  volatile uint32_t SA2;                         
N       uint32_t RESERVED1[45];
N  __IO uint32_t Command;                    /*!< Offset: 0x100 (R/W)  Command Register */
X  volatile uint32_t Command;                     
N  __I  uint32_t Status;                     /*!< Offset: 0x104 (R/ )  Status Register */
X  volatile const  uint32_t Status;                      
N  __IO uint32_t RxDescriptor;               /*!< Offset: 0x108 (R/W)  Receive Descriptor Base Address Register */
X  volatile uint32_t RxDescriptor;                
N  __IO uint32_t RxStatus;                   /*!< Offset: 0x10C (R/W)  Receive Status Base Address Register */
X  volatile uint32_t RxStatus;                    
N  __IO uint32_t RxDescriptorNumber;         /*!< Offset: 0x110 (R/W)  Receive Number of Descriptors Register */
X  volatile uint32_t RxDescriptorNumber;          
N  __I  uint32_t RxProduceIndex;             /*!< Offset: 0x114 (R/ )  Receive Produce Index Register */
X  volatile const  uint32_t RxProduceIndex;              
N  __IO uint32_t RxConsumeIndex;             /*!< Offset: 0x118 (R/W)  Receive Consume Index Register */
X  volatile uint32_t RxConsumeIndex;              
N  __IO uint32_t TxDescriptor;               /*!< Offset: 0x11C (R/W)  Transmit Descriptor Base Address Register */
X  volatile uint32_t TxDescriptor;                
N  __IO uint32_t TxStatus;                   /*!< Offset: 0x120 (R/W)  Transmit Status Base Address Register */
X  volatile uint32_t TxStatus;                    
N  __IO uint32_t TxDescriptorNumber;         /*!< Offset: 0x124 (R/W)  Transmit Number of Descriptors Register */
X  volatile uint32_t TxDescriptorNumber;          
N  __IO uint32_t TxProduceIndex;             /*!< Offset: 0x128 (R/W)  Transmit Produce Index Register */
X  volatile uint32_t TxProduceIndex;              
N  __I  uint32_t TxConsumeIndex;             /*!< Offset: 0x12C (R/ )  Transmit Consume Index Register */
X  volatile const  uint32_t TxConsumeIndex;              
N       uint32_t RESERVED2[10];
N  __I  uint32_t TSV0;                       /*!< Offset: 0x158 (R/ )  Transmit Status Vector 0 Register */
X  volatile const  uint32_t TSV0;                        
N  __I  uint32_t TSV1;                       /*!< Offset: 0x15C (R/ )  Transmit Status Vector 1 Register */
X  volatile const  uint32_t TSV1;                        
N  __I  uint32_t RSV;                        /*!< Offset: 0x160 (R/ )  Receive Status Vector Register */
X  volatile const  uint32_t RSV;                         
N       uint32_t RESERVED3[3];
N  __IO uint32_t FlowControlCounter;         /*!< Offset: 0x170 (R/W)  Flow Control Counter Register */
X  volatile uint32_t FlowControlCounter;          
N  __I  uint32_t FlowControlStatus;          /*!< Offset: 0x174 (R/ )  Flow Control Status egister */
X  volatile const  uint32_t FlowControlStatus;           
N       uint32_t RESERVED4[34];
N  __IO uint32_t RxFilterCtrl;               /*!< Offset: 0x200 (R/W)  Receive Filter Control Register */
X  volatile uint32_t RxFilterCtrl;                
N  __I  uint32_t RxFilterWoLStatus;          /*!< Offset: 0x204 (R/ )  Receive Filter WoL Status Register */
X  volatile const  uint32_t RxFilterWoLStatus;           
N  __O  uint32_t RxFilterWoLClear;           /*!< Offset: 0x208 ( /W)  Receive Filter WoL Clear Register */
X  volatile  uint32_t RxFilterWoLClear;            
N       uint32_t RESERVED5;
N  __IO uint32_t HashFilterL;                /*!< Offset: 0x210 (R/W)  Hash Filter Table LSBs Register */
X  volatile uint32_t HashFilterL;                 
N  __IO uint32_t HashFilterH;                /*!< Offset: 0x214 (R/W)  Hash Filter Table MSBs Register */
X  volatile uint32_t HashFilterH;                 
N       uint32_t RESERVED6[882];
N  __I  uint32_t IntStatus;                  /*!< Offset: 0xFE0 (R/ )  Interrupt Status Register */
X  volatile const  uint32_t IntStatus;                   
N  __IO uint32_t IntEnable;                  /*!< Offset: 0xFE4 (R/W)  Interrupt Enable Register */
X  volatile uint32_t IntEnable;                   
N  __O  uint32_t IntClear;                   /*!< Offset: 0xFE8 ( /W)  Interrupt Clear Register */
X  volatile  uint32_t IntClear;                    
N  __O  uint32_t IntSet;                     /*!< Offset: 0xFEC ( /W)  Interrupt Set Register */
X  volatile  uint32_t IntSet;                      
N       uint32_t RESERVED7;
N  __IO uint32_t PowerDown;                  /*!< Offset: 0xFF4 (R/W)  Power-Down Register */
X  volatile uint32_t PowerDown;                   
N} LPC_EMAC_TypeDef;
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma no_anon_unions
N#endif
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/* Base addresses                                                             */
N#define LPC_FLASH_BASE        (0x00000000UL)
N#define LPC_RAM_BASE          (0x10000000UL)
N#ifdef __LPC17XX_REV00
S#define LPC_AHBRAM0_BASE      (0x20000000UL)
S#define LPC_AHBRAM1_BASE      (0x20004000UL)
N#else
N#define LPC_AHBRAM0_BASE      (0x2007C000UL)
N#define LPC_AHBRAM1_BASE      (0x20080000UL)
N#endif
N#define LPC_GPIO_BASE         (0x2009C000UL)
N#define LPC_APB0_BASE         (0x40000000UL)
N#define LPC_APB1_BASE         (0x40080000UL)
N#define LPC_AHB_BASE          (0x50000000UL)
N#define LPC_CM3_BASE          (0xE0000000UL)
N
N/* APB0 peripherals                                                           */
N#define LPC_WDT_BASE          (LPC_APB0_BASE + 0x00000)
N#define LPC_TIM0_BASE         (LPC_APB0_BASE + 0x04000)
N#define LPC_TIM1_BASE         (LPC_APB0_BASE + 0x08000)
N#define LPC_UART0_BASE        (LPC_APB0_BASE + 0x0C000)
N#define LPC_UART1_BASE        (LPC_APB0_BASE + 0x10000)
N#define LPC_PWM1_BASE         (LPC_APB0_BASE + 0x18000)
N#define LPC_I2C0_BASE         (LPC_APB0_BASE + 0x1C000)
N#define LPC_SPI_BASE          (LPC_APB0_BASE + 0x20000)
N#define LPC_RTC_BASE          (LPC_APB0_BASE + 0x24000)
N#define LPC_GPIOINT_BASE      (LPC_APB0_BASE + 0x28080)
N#define LPC_PINCON_BASE       (LPC_APB0_BASE + 0x2C000)
N#define LPC_SSP1_BASE         (LPC_APB0_BASE + 0x30000)
N#define LPC_ADC_BASE          (LPC_APB0_BASE + 0x34000)
N#define LPC_CANAF_RAM_BASE    (LPC_APB0_BASE + 0x38000)
N#define LPC_CANAF_BASE        (LPC_APB0_BASE + 0x3C000)
N#define LPC_CANCR_BASE        (LPC_APB0_BASE + 0x40000)
N#define LPC_CAN1_BASE         (LPC_APB0_BASE + 0x44000)
N#define LPC_CAN2_BASE         (LPC_APB0_BASE + 0x48000)
N#define LPC_I2C1_BASE         (LPC_APB0_BASE + 0x5C000)
N
N/* APB1 peripherals                                                           */
N#define LPC_SSP0_BASE         (LPC_APB1_BASE + 0x08000)
N#define LPC_DAC_BASE          (LPC_APB1_BASE + 0x0C000)
N#define LPC_TIM2_BASE         (LPC_APB1_BASE + 0x10000)
N#define LPC_TIM3_BASE         (LPC_APB1_BASE + 0x14000)
N#define LPC_UART2_BASE        (LPC_APB1_BASE + 0x18000)
N#define LPC_UART3_BASE        (LPC_APB1_BASE + 0x1C000)
N#define LPC_I2C2_BASE         (LPC_APB1_BASE + 0x20000)
N#define LPC_I2S_BASE          (LPC_APB1_BASE + 0x28000)
N#define LPC_RIT_BASE          (LPC_APB1_BASE + 0x30000)
N#define LPC_MCPWM_BASE        (LPC_APB1_BASE + 0x38000)
N#define LPC_QEI_BASE          (LPC_APB1_BASE + 0x3C000)
N#define LPC_SC_BASE           (LPC_APB1_BASE + 0x7C000)
N
N/* AHB peripherals                                                            */
N#define LPC_EMAC_BASE         (LPC_AHB_BASE  + 0x00000)
N#define LPC_GPDMA_BASE        (LPC_AHB_BASE  + 0x04000)
N#define LPC_GPDMACH0_BASE     (LPC_AHB_BASE  + 0x04100)
N#define LPC_GPDMACH1_BASE     (LPC_AHB_BASE  + 0x04120)
N#define LPC_GPDMACH2_BASE     (LPC_AHB_BASE  + 0x04140)
N#define LPC_GPDMACH3_BASE     (LPC_AHB_BASE  + 0x04160)
N#define LPC_GPDMACH4_BASE     (LPC_AHB_BASE  + 0x04180)
N#define LPC_GPDMACH5_BASE     (LPC_AHB_BASE  + 0x041A0)
N#define LPC_GPDMACH6_BASE     (LPC_AHB_BASE  + 0x041C0)
N#define LPC_GPDMACH7_BASE     (LPC_AHB_BASE  + 0x041E0)
N#define LPC_USB_BASE          (LPC_AHB_BASE  + 0x0C000)
N
N/* GPIOs                                                                      */
N#define LPC_GPIO0_BASE        (LPC_GPIO_BASE + 0x00000)
N#define LPC_GPIO1_BASE        (LPC_GPIO_BASE + 0x00020)
N#define LPC_GPIO2_BASE        (LPC_GPIO_BASE + 0x00040)
N#define LPC_GPIO3_BASE        (LPC_GPIO_BASE + 0x00060)
N#define LPC_GPIO4_BASE        (LPC_GPIO_BASE + 0x00080)
N
N
N/******************************************************************************/
N/*                         Peripheral declaration                             */
N/******************************************************************************/
N#define LPC_SC                ((LPC_SC_TypeDef        *) LPC_SC_BASE       )
N#define LPC_GPIO0             ((LPC_GPIO_TypeDef      *) LPC_GPIO0_BASE    )
N#define LPC_GPIO1             ((LPC_GPIO_TypeDef      *) LPC_GPIO1_BASE    )
N#define LPC_GPIO2             ((LPC_GPIO_TypeDef      *) LPC_GPIO2_BASE    )
N#define LPC_GPIO3             ((LPC_GPIO_TypeDef      *) LPC_GPIO3_BASE    )
N#define LPC_GPIO4             ((LPC_GPIO_TypeDef      *) LPC_GPIO4_BASE    )
N#define LPC_WDT               ((LPC_WDT_TypeDef       *) LPC_WDT_BASE      )
N#define LPC_TIM0              ((LPC_TIM_TypeDef       *) LPC_TIM0_BASE     )
N#define LPC_TIM1              ((LPC_TIM_TypeDef       *) LPC_TIM1_BASE     )
N#define LPC_TIM2              ((LPC_TIM_TypeDef       *) LPC_TIM2_BASE     )
N#define LPC_TIM3              ((LPC_TIM_TypeDef       *) LPC_TIM3_BASE     )
N#define LPC_RIT               ((LPC_RIT_TypeDef       *) LPC_RIT_BASE      )
N#define LPC_UART0             ((LPC_UART_TypeDef      *) LPC_UART0_BASE    )
N#define LPC_UART1             ((LPC_UART1_TypeDef     *) LPC_UART1_BASE    )
N#define LPC_UART2             ((LPC_UART_TypeDef      *) LPC_UART2_BASE    )
N#define LPC_UART3             ((LPC_UART_TypeDef      *) LPC_UART3_BASE    )
N#define LPC_PWM1              ((LPC_PWM_TypeDef       *) LPC_PWM1_BASE     )
N#define LPC_I2C0              ((LPC_I2C_TypeDef       *) LPC_I2C0_BASE     )
N#define LPC_I2C1              ((LPC_I2C_TypeDef       *) LPC_I2C1_BASE     )
N#define LPC_I2C2              ((LPC_I2C_TypeDef       *) LPC_I2C2_BASE     )
N#define LPC_I2S               ((LPC_I2S_TypeDef       *) LPC_I2S_BASE      )
N#define LPC_SPI               ((LPC_SPI_TypeDef       *) LPC_SPI_BASE      )
N#define LPC_RTC               ((LPC_RTC_TypeDef       *) LPC_RTC_BASE      )
N#define LPC_GPIOINT           ((LPC_GPIOINT_TypeDef   *) LPC_GPIOINT_BASE  )
N#define LPC_PINCON            ((LPC_PINCON_TypeDef    *) LPC_PINCON_BASE   )
N#define LPC_SSP0              ((LPC_SSP_TypeDef       *) LPC_SSP0_BASE     )
N#define LPC_SSP1              ((LPC_SSP_TypeDef       *) LPC_SSP1_BASE     )
N#define LPC_ADC               ((LPC_ADC_TypeDef       *) LPC_ADC_BASE      )
N#define LPC_DAC               ((LPC_DAC_TypeDef       *) LPC_DAC_BASE      )
N#define LPC_CANAF_RAM         ((LPC_CANAF_RAM_TypeDef *) LPC_CANAF_RAM_BASE)
N#define LPC_CANAF             ((LPC_CANAF_TypeDef     *) LPC_CANAF_BASE    )
N#define LPC_CANCR             ((LPC_CANCR_TypeDef     *) LPC_CANCR_BASE    )
N#define LPC_CAN1              ((LPC_CAN_TypeDef       *) LPC_CAN1_BASE     )
N#define LPC_CAN2              ((LPC_CAN_TypeDef       *) LPC_CAN2_BASE     )
N#define LPC_MCPWM             ((LPC_MCPWM_TypeDef     *) LPC_MCPWM_BASE    )
N#define LPC_QEI               ((LPC_QEI_TypeDef       *) LPC_QEI_BASE      )
N#define LPC_EMAC              ((LPC_EMAC_TypeDef      *) LPC_EMAC_BASE     )
N#define LPC_GPDMA             ((LPC_GPDMA_TypeDef     *) LPC_GPDMA_BASE    )
N#define LPC_GPDMACH0          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH0_BASE )
N#define LPC_GPDMACH1          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH1_BASE )
N#define LPC_GPDMACH2          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH2_BASE )
N#define LPC_GPDMACH3          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH3_BASE )
N#define LPC_GPDMACH4          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH4_BASE )
N#define LPC_GPDMACH5          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH5_BASE )
N#define LPC_GPDMACH6          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH6_BASE )
N#define LPC_GPDMACH7          ((LPC_GPDMACH_TypeDef   *) LPC_GPDMACH7_BASE )
N#define LPC_USB               ((LPC_USB_TypeDef       *) LPC_USB_BASE      )
N
N/**
N * @}
N */
N
N#endif  // __LPC17xx_H__
L 24 "usbhw.c" 2
N
N#include "type.h"
L 1 "type.h" 1
N/*****************************************************************************
N *   type.h:  Type definition Header file for NXP LPC17xx Family 
N *   Microprocessors
N *
N *   Copyright(C) 2009, NXP Semiconductor
N *   All rights reserved.
N *
N *   History
N *   2009.05.25  ver 1.00    Prelimnary version, first Release
N *
N******************************************************************************/
N#include <stdint.h>
N
N#ifndef __TYPE_H__
N#define __TYPE_H__
N
N#ifndef NULL
N#define NULL    ((void *)0)
N#endif
N
N#ifndef FALSE
N#define FALSE   (0)
N#endif
N
N#ifndef TRUE
N#define TRUE    (1)
N#endif
N
N
Ntypedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;
Ntypedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
N
N#endif  /* __TYPE_H__ */
L 26 "usbhw.c" 2
N
N#include "usb.h"
L 1 "usb.h" 1
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usb.h
N * Purpose: USB Definitions
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __USB_H__
N#define __USB_H__
N
N
Ntypedef __packed union {
N  uint16_t W;
N  __packed struct {
N    uint8_t L;
N    uint8_t H;
N  } WB;
N} WORD_BYTE;
N
N
N/* bmRequestType.Dir */
N#define REQUEST_HOST_TO_DEVICE     0
N#define REQUEST_DEVICE_TO_HOST     1
N
N/* bmRequestType.Type */
N#define REQUEST_STANDARD           0
N#define REQUEST_CLASS              1
N#define REQUEST_VENDOR             2
N#define REQUEST_RESERVED           3
N
N/* bmRequestType.Recipient */
N#define REQUEST_TO_DEVICE          0
N#define REQUEST_TO_INTERFACE       1
N#define REQUEST_TO_ENDPOINT        2
N#define REQUEST_TO_OTHER           3
N
N/* bmRequestType Definition */
Ntypedef __packed union _REQUEST_TYPE {
N  __packed struct _BM {
N    uint8_t Recipient : 5;
N    uint8_t Type      : 2;
N    uint8_t Dir       : 1;
N  } BM;
N  uint8_t B;
N} REQUEST_TYPE;
N
N/* USB Standard Request Codes */
N#define USB_REQUEST_GET_STATUS                 0
N#define USB_REQUEST_CLEAR_FEATURE              1
N#define USB_REQUEST_SET_FEATURE                3
N#define USB_REQUEST_SET_ADDRESS                5
N#define USB_REQUEST_GET_DESCRIPTOR             6
N#define USB_REQUEST_SET_DESCRIPTOR             7
N#define USB_REQUEST_GET_CONFIGURATION          8
N#define USB_REQUEST_SET_CONFIGURATION          9
N#define USB_REQUEST_GET_INTERFACE              10
N#define USB_REQUEST_SET_INTERFACE              11
N#define USB_REQUEST_SYNC_FRAME                 12
N
N/* USB GET_STATUS Bit Values */
N#define USB_GETSTATUS_SELF_POWERED             0x01
N#define USB_GETSTATUS_REMOTE_WAKEUP            0x02
N#define USB_GETSTATUS_ENDPOINT_STALL           0x01
N
N/* USB Standard Feature selectors */
N#define USB_FEATURE_ENDPOINT_STALL             0
N#define USB_FEATURE_REMOTE_WAKEUP              1
N
N/* USB Default Control Pipe Setup Packet */
Ntypedef __packed struct _USB_SETUP_PACKET {
N  REQUEST_TYPE bmRequestType;
N  uint8_t         bRequest;
N  WORD_BYTE    wValue;
N  WORD_BYTE    wIndex;
N  uint16_t         wLength;
N} USB_SETUP_PACKET;
N
N
N/* USB Descriptor Types */
N#define USB_DEVICE_DESCRIPTOR_TYPE                  1
N#define USB_CONFIGURATION_DESCRIPTOR_TYPE           2
N#define USB_STRING_DESCRIPTOR_TYPE                  3
N#define USB_INTERFACE_DESCRIPTOR_TYPE               4
N#define USB_ENDPOINT_DESCRIPTOR_TYPE                5
N#define USB_DEVICE_QUALIFIER_DESCRIPTOR_TYPE        6
N#define USB_OTHER_SPEED_CONFIG_DESCRIPTOR_TYPE      7
N#define USB_INTERFACE_POWER_DESCRIPTOR_TYPE         8
N#define USB_OTG_DESCRIPTOR_TYPE                     9
N#define USB_DEBUG_DESCRIPTOR_TYPE                  10
N#define USB_INTERFACE_ASSOCIATION_DESCRIPTOR_TYPE  11 
N
N/* USB Device Classes */
N#define USB_DEVICE_CLASS_RESERVED              0x00
N#define USB_DEVICE_CLASS_AUDIO                 0x01
N#define USB_DEVICE_CLASS_COMMUNICATIONS        0x02
N#define USB_DEVICE_CLASS_HUMAN_INTERFACE       0x03
N#define USB_DEVICE_CLASS_MONITOR               0x04
N#define USB_DEVICE_CLASS_PHYSICAL_INTERFACE    0x05
N#define USB_DEVICE_CLASS_POWER                 0x06
N#define USB_DEVICE_CLASS_PRINTER               0x07
N#define USB_DEVICE_CLASS_STORAGE               0x08
N#define USB_DEVICE_CLASS_HUB                   0x09
N#define USB_DEVICE_CLASS_MISCELLANEOUS         0xEF
N#define USB_DEVICE_CLASS_VENDOR_SPECIFIC       0xFF
N
N/* bmAttributes in Configuration Descriptor */
N#define USB_CONFIG_POWERED_MASK                0x40
N#define USB_CONFIG_BUS_POWERED                 0x80
N#define USB_CONFIG_SELF_POWERED                0xC0
N#define USB_CONFIG_REMOTE_WAKEUP               0x20
N
N/* bMaxPower in Configuration Descriptor */
N#define USB_CONFIG_POWER_MA(mA)                ((mA)/2)
N
N/* bEndpointAddress in Endpoint Descriptor */
N#define USB_ENDPOINT_DIRECTION_MASK            0x80
N#define USB_ENDPOINT_OUT(addr)                 ((addr) | 0x00)
N#define USB_ENDPOINT_IN(addr)                  ((addr) | 0x80)
N
N/* bmAttributes in Endpoint Descriptor */
N#define USB_ENDPOINT_TYPE_MASK                 0x03
N#define USB_ENDPOINT_TYPE_CONTROL              0x00
N#define USB_ENDPOINT_TYPE_ISOCHRONOUS          0x01
N#define USB_ENDPOINT_TYPE_BULK                 0x02
N#define USB_ENDPOINT_TYPE_INTERRUPT            0x03
N#define USB_ENDPOINT_SYNC_MASK                 0x0C
N#define USB_ENDPOINT_SYNC_NO_SYNCHRONIZATION   0x00
N#define USB_ENDPOINT_SYNC_ASYNCHRONOUS         0x04
N#define USB_ENDPOINT_SYNC_ADAPTIVE             0x08
N#define USB_ENDPOINT_SYNC_SYNCHRONOUS          0x0C
N#define USB_ENDPOINT_USAGE_MASK                0x30
N#define USB_ENDPOINT_USAGE_DATA                0x00
N#define USB_ENDPOINT_USAGE_FEEDBACK            0x10
N#define USB_ENDPOINT_USAGE_IMPLICIT_FEEDBACK   0x20
N#define USB_ENDPOINT_USAGE_RESERVED            0x30
N
N/* USB Standard Device Descriptor */
Ntypedef __packed struct _USB_DEVICE_DESCRIPTOR {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint16_t  bcdUSB;
N  uint8_t  bDeviceClass;
N  uint8_t  bDeviceSubClass;
N  uint8_t  bDeviceProtocol;
N  uint8_t  bMaxPacketSize0;
N  uint16_t  idVendor;
N  uint16_t  idProduct;
N  uint16_t  bcdDevice;
N  uint8_t  iManufacturer;
N  uint8_t  iProduct;
N  uint8_t  iSerialNumber;
N  uint8_t  bNumConfigurations;
N} USB_DEVICE_DESCRIPTOR;
N
N/* USB 2.0 Device Qualifier Descriptor */
Ntypedef __packed struct _USB_DEVICE_QUALIFIER_DESCRIPTOR {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint16_t  bcdUSB;
N  uint8_t  bDeviceClass;
N  uint8_t  bDeviceSubClass;
N  uint8_t  bDeviceProtocol;
N  uint8_t  bMaxPacketSize0;
N  uint8_t  bNumConfigurations;
N  uint8_t  bReserved;
N} USB_DEVICE_QUALIFIER_DESCRIPTOR;
N
N/* USB Standard Configuration Descriptor */
Ntypedef __packed struct _USB_CONFIGURATION_DESCRIPTOR {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint16_t  wTotalLength;
N  uint8_t  bNumInterfaces;
N  uint8_t  bConfigurationValue;
N  uint8_t  iConfiguration;
N  uint8_t  bmAttributes;
N  uint8_t  bMaxPower;
N} USB_CONFIGURATION_DESCRIPTOR;
N
N/* USB Standard Interface Descriptor */
Ntypedef __packed struct _USB_INTERFACE_DESCRIPTOR {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint8_t  bInterfaceNumber;
N  uint8_t  bAlternateSetting;
N  uint8_t  bNumEndpoints;
N  uint8_t  bInterfaceClass;
N  uint8_t  bInterfaceSubClass;
N  uint8_t  bInterfaceProtocol;
N  uint8_t  iInterface;
N} USB_INTERFACE_DESCRIPTOR;
N
N/* USB Standard Endpoint Descriptor */
Ntypedef __packed struct _USB_ENDPOINT_DESCRIPTOR {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint8_t  bEndpointAddress;
N  uint8_t  bmAttributes;
N  uint16_t  wMaxPacketSize;
N  uint8_t  bInterval;
N} USB_ENDPOINT_DESCRIPTOR;
N
N/* USB String Descriptor */
Ntypedef __packed struct _USB_STRING_DESCRIPTOR {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N  uint16_t  bString/*[]*/;
N} USB_STRING_DESCRIPTOR;
N
N/* USB Common Descriptor */
Ntypedef __packed struct _USB_COMMON_DESCRIPTOR {
N  uint8_t  bLength;
N  uint8_t  bDescriptorType;
N} USB_COMMON_DESCRIPTOR;
N
N
N#endif  /* __USB_H__ */
L 28 "usbhw.c" 2
N#include "usbcfg.h"
L 1 "usbcfg.h" 1
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usbcfg.h
N * Purpose: USB Custom Configuration
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *----------------------------------------------------------------------------
N * History:
N *          V1.20 Added vendor specific support
N *          V1.00 Initial Version
N *----------------------------------------------------------------------------*/
N
N#ifndef __USBCFG_H__
N#define __USBCFG_H__
N
N
N//*** <<< Use Configuration Wizard in Context Menu >>> ***
N
N
N/*
N// <h> USB Configuration
N//   <o0> USB Power
N//        <i> Default Power Setting
N//        <0=> Bus-powered
N//        <1=> Self-powered
N//   <o1> Max Number of Interfaces <1-256>
N//   <o2> Max Number of Endpoints  <1-32>
N//   <o3> Max Endpoint 0 Packet Size
N//        <8=> 8 Bytes <16=> 16 Bytes <32=> 32 Bytes <64=> 64 Bytes
N//   <e4> DMA Transfer
N//     <i> Use DMA for selected Endpoints
N//     <o5.0>  Endpoint 0 Out
N//     <o5.1>  Endpoint 0 In
N//     <o5.2>  Endpoint 1 Out
N//     <o5.3>  Endpoint 1 In
N//     <o5.4>  Endpoint 2 Out
N//     <o5.5>  Endpoint 2 In
N//     <o5.6>  Endpoint 3 Out
N//     <o5.7>  Endpoint 3 In
N//     <o5.8>  Endpoint 4 Out
N//     <o5.9>  Endpoint 4 In
N//     <o5.10> Endpoint 5 Out
N//     <o5.11> Endpoint 5 In
N//     <o5.12> Endpoint 6 Out
N//     <o5.13> Endpoint 6 In
N//     <o5.14> Endpoint 7 Out
N//     <o5.15> Endpoint 7 In
N//     <o5.16> Endpoint 8 Out
N//     <o5.17> Endpoint 8 In
N//     <o5.18> Endpoint 9 Out
N//     <o5.19> Endpoint 9 In
N//     <o5.20> Endpoint 10 Out
N//     <o5.21> Endpoint 10 In
N//     <o5.22> Endpoint 11 Out
N//     <o5.23> Endpoint 11 In
N//     <o5.24> Endpoint 12 Out
N//     <o5.25> Endpoint 12 In
N//     <o5.26> Endpoint 13 Out
N//     <o5.27> Endpoint 13 In
N//     <o5.28> Endpoint 14 Out
N//     <o5.29> Endpoint 14 In
N//     <o5.30> Endpoint 15 Out
N//     <o5.31> Endpoint 15 In
N//   </e>
N// </h>
N*/
N
N#define USB_POWER           0
N#define USB_IF_NUM          4
N#define USB_EP_NUM          32
N#define USB_MAX_PACKET0     64
N#define USB_DMA             1
N#define USB_DMA_EP          0x00000040
N
N
N/*
N// <h> USB Event Handlers
N//   <h> Device Events
N//     <o0.0> Power Event
N//     <o1.0> Reset Event
N//     <o2.0> Suspend Event
N//     <o3.0> Resume Event
N//     <o4.0> Remote Wakeup Event
N//     <o5.0> Start of Frame Event
N//     <o6.0> Error Event
N//   </h>
N//   <h> Endpoint Events
N//     <o7.0>  Endpoint 0 Event
N//     <o7.1>  Endpoint 1 Event
N//     <o7.2>  Endpoint 2 Event
N//     <o7.3>  Endpoint 3 Event
N//     <o7.4>  Endpoint 4 Event
N//     <o7.5>  Endpoint 5 Event
N//     <o7.6>  Endpoint 6 Event
N//     <o7.7>  Endpoint 7 Event
N//     <o7.8>  Endpoint 8 Event
N//     <o7.9>  Endpoint 9 Event
N//     <o7.10> Endpoint 10 Event
N//     <o7.11> Endpoint 11 Event
N//     <o7.12> Endpoint 12 Event
N//     <o7.13> Endpoint 13 Event
N//     <o7.14> Endpoint 14 Event
N//     <o7.15> Endpoint 15 Event
N//   </h>
N//   <h> USB Core Events
N//     <o8.0>  Set Configuration Event
N//     <o9.0>  Set Interface Event
N//     <o10.0> Set/Clear Feature Event
N//   </h>
N// </h>
N*/
N
N#define USB_POWER_EVENT     0
N#define USB_RESET_EVENT     1
N#define USB_SUSPEND_EVENT   0
N#define USB_RESUME_EVENT    0
N#define USB_WAKEUP_EVENT    0
N#define USB_SOF_EVENT       1
N#define USB_ERROR_EVENT     0
N#define USB_EP_EVENT        0x0009
N#define USB_CONFIGURE_EVENT 0
N#define USB_INTERFACE_EVENT 0
N#define USB_FEATURE_EVENT   0
N
N
N/*
N// <e0> USB Class Support
N//   <i> enables USB Class specific Requests
N//   <e1> Human Interface Device (HID)
N//     <o2> Interface Number <0-255>
N//   </e>
N//   <e3> Mass Storage
N//     <o4> Interface Number <0-255>
N//   </e>
N//   <e5> Audio Device
N//     <o6> Control Interface Number <0-255>
N//     <o7> Streaming Interface 1 Number <0-255>
N//     <o8> Streaming Interface 2 Number <0-255>
N//   </e>
N//   <e9> Communication Device
N//     <o10> Control Interface Number <0-255>
N//     <o11> Bulk Interface Number <0-255>
N//     <o12> Max Communication Device Buffer Size
N//        <8=> 8 Bytes <16=> 16 Bytes <32=> 32 Bytes <64=> 64 Bytes 
N//   </e>
N// </e>
N*/
N
N#define USB_CLASS           1
N#define USB_HID             0
N#define USB_HID_IF_NUM      0
N#define USB_MSC             0
N#define USB_MSC_IF_NUM      0
N#define USB_AUDIO           1
N#define USB_ADC_CIF_NUM     0
N#define USB_ADC_SIF1_NUM    1
N#define USB_ADC_SIF2_NUM    2
N#define USB_CDC  			0
N#define USB_CDC_CIF_NUM     0
N#define USB_CDC_DIF_NUM     1
N#define USB_CDC_BUFSIZE     64
N
N/*
N// <e0> USB Vendor Support
N//   <i> enables USB Vendor specific Requests
N// </e>
N*/
N#define USB_VENDOR          0
N
N
N#endif  /* __USBCFG_H__ */
L 29 "usbhw.c" 2
N#include "usbreg.h"
L 1 "usbreg.h" 1
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usbreg.h
N * Purpose: USB Hardware Layer Definitions for NXP LPC Family MCUs
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __USBREG_H
N#define __USBREG_H
N
N/* Device Interrupt Bit Definitions */
N#define FRAME_INT           0x00000001
N#define EP_FAST_INT         0x00000002
N#define EP_SLOW_INT         0x00000004
N#define DEV_STAT_INT        0x00000008
N#define CCEMTY_INT          0x00000010
N#define CDFULL_INT          0x00000020
N#define RxENDPKT_INT        0x00000040
N#define TxENDPKT_INT        0x00000080
N#define EP_RLZED_INT        0x00000100
N#define ERR_INT             0x00000200
N
N/* Rx & Tx Packet Length Definitions */
N#define PKT_LNGTH_MASK      0x000003FF
N#define PKT_DV              0x00000400
N#define PKT_RDY             0x00000800
N
N/* USB Control Definitions */
N#define CTRL_RD_EN          0x00000001
N#define CTRL_WR_EN          0x00000002
N
N/* Command Codes */
N#define CMD_SET_ADDR        0x00D00500
N#define CMD_CFG_DEV         0x00D80500
N#define CMD_SET_MODE        0x00F30500
N#define CMD_RD_FRAME        0x00F50500
N#define DAT_RD_FRAME        0x00F50200
N#define CMD_RD_TEST         0x00FD0500
N#define DAT_RD_TEST         0x00FD0200
N#define CMD_SET_DEV_STAT    0x00FE0500
N#define CMD_GET_DEV_STAT    0x00FE0500
N#define DAT_GET_DEV_STAT    0x00FE0200
N#define CMD_GET_ERR_CODE    0x00FF0500
N#define DAT_GET_ERR_CODE    0x00FF0200
N#define CMD_RD_ERR_STAT     0x00FB0500
N#define DAT_RD_ERR_STAT     0x00FB0200
N#define DAT_WR_BYTE(x)     (0x00000100 | ((x) << 16))
N#define CMD_SEL_EP(x)      (0x00000500 | ((x) << 16))
N#define DAT_SEL_EP(x)      (0x00000200 | ((x) << 16))
N#define CMD_SEL_EP_CLRI(x) (0x00400500 | ((x) << 16))
N#define DAT_SEL_EP_CLRI(x) (0x00400200 | ((x) << 16))
N#define CMD_SET_EP_STAT(x) (0x00400500 | ((x) << 16))
N#define CMD_CLR_BUF         0x00F20500
N#define DAT_CLR_BUF         0x00F20200
N#define CMD_VALID_BUF       0x00FA0500
N
N/* Device Address Register Definitions */
N#define DEV_ADDR_MASK       0x7F
N#define DEV_EN              0x80
N
N/* Device Configure Register Definitions */
N#define CONF_DVICE          0x01
N
N/* Device Mode Register Definitions */
N#define AP_CLK              0x01
N#define INAK_CI             0x02
N#define INAK_CO             0x04
N#define INAK_II             0x08
N#define INAK_IO             0x10
N#define INAK_BI             0x20
N#define INAK_BO             0x40
N
N/* Device Status Register Definitions */
N#define DEV_CON             0x01
N#define DEV_CON_CH          0x02
N#define DEV_SUS             0x04
N#define DEV_SUS_CH          0x08
N#define DEV_RST             0x10
N
N/* Error Code Register Definitions */
N#define ERR_EC_MASK         0x0F
N#define ERR_EA              0x10
N
N/* Error Status Register Definitions */
N#define ERR_PID             0x01
N#define ERR_UEPKT           0x02
N#define ERR_DCRC            0x04
N#define ERR_TIMOUT          0x08
N#define ERR_EOP             0x10
N#define ERR_B_OVRN          0x20
N#define ERR_BTSTF           0x40
N#define ERR_TGL             0x80
N
N/* Endpoint Select Register Definitions */
N#define EP_SEL_F            0x01
N#define EP_SEL_ST           0x02
N#define EP_SEL_STP          0x04
N#define EP_SEL_PO           0x08
N#define EP_SEL_EPN          0x10
N#define EP_SEL_B_1_FULL     0x20
N#define EP_SEL_B_2_FULL     0x40
N
N/* Endpoint Status Register Definitions */
N#define EP_STAT_ST          0x01
N#define EP_STAT_DA          0x20
N#define EP_STAT_RF_MO       0x40
N#define EP_STAT_CND_ST      0x80
N
N/* Clear Buffer Register Definitions */
N#define CLR_BUF_PO          0x01
N
N
N/* DMA Interrupt Bit Definitions */
N#define EOT_INT             0x01
N#define NDD_REQ_INT         0x02
N#define SYS_ERR_INT         0x04
N
N
N#endif  /* __USBREG_H */
L 30 "usbhw.c" 2
N#include "usbhw.h"
L 1 "usbhw.h" 1
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usbhw.h
N * Purpose: USB Hardware Layer Definitions
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *----------------------------------------------------------------------------
N * History:
N *          V1.20 Added USB_ClearEPBuf 
N *          V1.00 Initial Version
N *----------------------------------------------------------------------------*/
N
N#ifndef __USBHW_H__
N#define __USBHW_H__
N
N
N/* USB RAM Definitions */
N#define USB_RAM_ADR     0x20080000  /* USB RAM Start Address */
N#define USB_RAM_SZ      0x00004000  /* USB RAM Size (4kB) */
N
N/* DMA Endpoint Descriptors */
N#define DD_NISO_CNT             16  /* Non-Iso EP DMA Descr. Count (max. 32) */
N#define DD_ISO_CNT               8  /* Iso EP DMA Descriptor Count (max. 32) */
N#define DD_NISO_SZ    (DD_NISO_CNT * 16)    /* Non-Iso DMA Descr. Size */
N#define DD_ISO_SZ     (DD_ISO_CNT  * 20)    /* Iso DMA Descriptor Size */
N#define DD_NISO_ADR   (USB_RAM_ADR + 128)   /* Non-Iso DMA Descr. Address */
N#define DD_ISO_ADR    (DD_NISO_ADR + DD_NISO_SZ) /* Iso DMA Descr. Address */
N#define DD_SZ                 (128 + DD_NISO_SZ + DD_ISO_SZ) /* Descr. Size */
N
N/* DMA Buffer Memory Definitions */
N#define DMA_BUF_ADR   (USB_RAM_ADR + DD_SZ) /* DMA Buffer Start Address */
N#define DMA_BUF_SZ    (USB_RAM_SZ  - DD_SZ) /* DMA Buffer Size */
N
N/* USB Error Codes */
N#define USB_ERR_PID         0x0001  /* PID Error */
N#define USB_ERR_UEPKT       0x0002  /* Unexpected Packet */
N#define USB_ERR_DCRC        0x0004  /* Data CRC Error */
N#define USB_ERR_TIMOUT      0x0008  /* Bus Time-out Error */
N#define USB_ERR_EOP         0x0010  /* End of Packet Error */
N#define USB_ERR_B_OVRN      0x0020  /* Buffer Overrun */
N#define USB_ERR_BTSTF       0x0040  /* Bit Stuff Error */
N#define USB_ERR_TGL         0x0080  /* Toggle Bit Error */
N
N/* USB DMA Status Codes */
N#define USB_DMA_INVALID     0x0000  /* DMA Invalid - Not Configured */
N#define USB_DMA_IDLE        0x0001  /* DMA Idle - Waiting for Trigger */
N#define USB_DMA_BUSY        0x0002  /* DMA Busy - Transfer in progress */
N#define USB_DMA_DONE        0x0003  /* DMA Transfer Done (no Errors)*/
N#define USB_DMA_OVER_RUN    0x0004  /* Data Over Run */
N#define USB_DMA_UNDER_RUN   0x0005  /* Data Under Run (Short Packet) */
N#define USB_DMA_ERROR       0x0006  /* Error */
N#define USB_DMA_UNKNOWN     0xFFFF  /* Unknown State */
N
N/* USB DMA Descriptor */
Ntypedef struct _USB_DMA_DESCRIPTOR {
N  uint32_t BufAdr;                     /* DMA Buffer Address */
N  uint16_t  BufLen;                     /* DMA Buffer Length */
N  uint16_t  MaxSize;                    /* Maximum Packet Size */
N  uint32_t InfoAdr;                    /* Packet Info Memory Address */
N  union {                           /* DMA Configuration */
N    struct {
N      uint32_t Link   : 1;             /* Link to existing Descriptors */
N      uint32_t IsoEP  : 1;             /* Isonchronous Endpoint */
N      uint32_t ATLE   : 1;             /* ATLE (Auto Transfer Length Extract) */
N      uint32_t Rsrvd  : 5;             /* Reserved */
N      uint32_t LenPos : 8;             /* Length Position (ATLE) */
N    } Type;
N    uint32_t Val;
N  } Cfg;
N} USB_DMA_DESCRIPTOR;
N
N/* USB Hardware Functions */
Nextern void  USB_Init       (void);
Nextern void  USB_Connect    (uint32_t  con);
Nextern void  USB_Reset      (void);
Nextern void  USB_Suspend    (void);
Nextern void  USB_Resume     (void);
Nextern void  USB_WakeUp     (void);
Nextern void  USB_WakeUpCfg  (uint32_t  cfg);
Nextern void  USB_SetAddress (uint32_t adr);
Nextern void  USB_Configure  (uint32_t  cfg);
Nextern void  USB_ConfigEP   (USB_ENDPOINT_DESCRIPTOR *pEPD);
Nextern void  USB_DirCtrlEP  (uint32_t dir);
Nextern void  USB_EnableEP   (uint32_t EPNum);
Nextern void  USB_DisableEP  (uint32_t EPNum);
Nextern void  USB_ResetEP    (uint32_t EPNum);
Nextern void  USB_SetStallEP (uint32_t EPNum);
Nextern void  USB_ClrStallEP (uint32_t EPNum);
Nextern void USB_ClearEPBuf  (uint32_t  EPNum);
Nextern uint32_t USB_ReadEP     (uint32_t EPNum, uint8_t *pData);
Nextern uint32_t USB_WriteEP    (uint32_t EPNum, uint8_t *pData, uint32_t cnt);
Nextern uint32_t  USB_DMA_Setup  (uint32_t EPNum, USB_DMA_DESCRIPTOR *pDD);
Nextern void  USB_DMA_Enable (uint32_t EPNum);
Nextern void  USB_DMA_Disable(uint32_t EPNum);
Nextern uint32_t USB_DMA_Status (uint32_t EPNum);
Nextern uint32_t USB_DMA_BufAdr (uint32_t EPNum);
Nextern uint32_t USB_DMA_BufCnt (uint32_t EPNum);
Nextern uint32_t USB_GetFrame   (void);
Nextern void  USB_IRQHandler (void);
N
N
N#endif  /* __USBHW_H__ */
L 31 "usbhw.c" 2
N#include "usbcore.h"
L 1 "usbcore.h" 1
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usbcore.h
N * Purpose: USB Core Definitions
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __USBCORE_H__
N#define __USBCORE_H__
N
N
N/* USB Endpoint Data Structure */
Ntypedef struct _USB_EP_DATA {
N  uint8_t  *pData;
N  uint16_t Count;
N} USB_EP_DATA;
N
N/* USB Core Global Variables */
Nextern uint16_t USB_DeviceStatus;
Nextern uint8_t  USB_DeviceAddress;
Nextern uint8_t  USB_Configuration;
Nextern uint32_t USB_EndPointMask;
Nextern uint32_t USB_EndPointHalt;
Nextern uint32_t USB_EndPointStall;
Nextern uint8_t  USB_AltSetting[USB_IF_NUM];
Xextern uint8_t  USB_AltSetting[4];
N
N/* USB Endpoint 0 Buffer */
Nextern uint8_t  EP0Buf[USB_MAX_PACKET0];
Xextern uint8_t  EP0Buf[64];
N
N/* USB Endpoint 0 Data Info */
Nextern USB_EP_DATA EP0Data;
N
N/* USB Setup Packet */
Nextern USB_SETUP_PACKET SetupPacket;
N
N/* USB Core Functions */
Nextern void USB_ResetCore (void);
N
N
N
N#endif  /* __USBCORE_H__ */
L 32 "usbhw.c" 2
N#include "usbuser.h"
L 1 "usbuser.h" 1
N/*----------------------------------------------------------------------------
N *      U S B  -  K e r n e l
N *----------------------------------------------------------------------------
N * Name:    usbuser.h
N * Purpose: USB Custom User Definitions
N * Version: V1.20
N *----------------------------------------------------------------------------
N *      This software is supplied "AS IS" without any warranties, express,
N *      implied or statutory, including but not limited to the implied
N *      warranties of fitness for purpose, satisfactory quality and
N *      noninfringement. Keil extends you a royalty-free right to reproduce
N *      and distribute executable files created using this software for use
N *      on NXP Semiconductors LPC family microcontroller devices only. Nothing 
N *      else gives you the right to use this software.
N *
N * Copyright (c) 2009 Keil - An ARM Company. All rights reserved.
N *---------------------------------------------------------------------------*/
N
N#ifndef __USBUSER_H__
N#define __USBUSER_H__
N
N
N/* USB Device Events Callback Functions */
Nextern void USB_Power_Event     (uint32_t  power);
Nextern void USB_Reset_Event     (void);
Nextern void USB_Suspend_Event   (void);
Nextern void USB_Resume_Event    (void);
Nextern void USB_WakeUp_Event    (void);
Nextern void USB_SOF_Event       (void);
Nextern void USB_Error_Event     (uint32_t error);
N
N/* USB Endpoint Callback Events */
N#define USB_EVT_SETUP       1   /* Setup Packet */
N#define USB_EVT_OUT         2   /* OUT Packet */
N#define USB_EVT_IN          3   /*  IN Packet */
N#define USB_EVT_OUT_NAK     4   /* OUT Packet - Not Acknowledged */
N#define USB_EVT_IN_NAK      5   /*  IN Packet - Not Acknowledged */
N#define USB_EVT_OUT_STALL   6   /* OUT Packet - Stalled */
N#define USB_EVT_IN_STALL    7   /*  IN Packet - Stalled */
N#define USB_EVT_OUT_DMA_EOT 8   /* DMA OUT EP - End of Transfer */
N#define USB_EVT_IN_DMA_EOT  9   /* DMA  IN EP - End of Transfer */
N#define USB_EVT_OUT_DMA_NDR 10  /* DMA OUT EP - New Descriptor Request */
N#define USB_EVT_IN_DMA_NDR  11  /* DMA  IN EP - New Descriptor Request */
N#define USB_EVT_OUT_DMA_ERR 12  /* DMA OUT EP - Error */
N#define USB_EVT_IN_DMA_ERR  13  /* DMA  IN EP - Error */
N
N/* USB Endpoint Events Callback Pointers */
Nextern void (* const USB_P_EP[16])(uint32_t event);
N
N/* USB Endpoint Events Callback Functions */
Nextern void USB_EndPoint0  (uint32_t event);
Nextern void USB_EndPoint1  (uint32_t event);
Nextern void USB_EndPoint2  (uint32_t event);
Nextern void USB_EndPoint3  (uint32_t event);
Nextern void USB_EndPoint4  (uint32_t event);
Nextern void USB_EndPoint5  (uint32_t event);
Nextern void USB_EndPoint6  (uint32_t event);
Nextern void USB_EndPoint7  (uint32_t event);
Nextern void USB_EndPoint8  (uint32_t event);
Nextern void USB_EndPoint9  (uint32_t event);
Nextern void USB_EndPoint10 (uint32_t event);
Nextern void USB_EndPoint11 (uint32_t event);
Nextern void USB_EndPoint12 (uint32_t event);
Nextern void USB_EndPoint13 (uint32_t event);
Nextern void USB_EndPoint14 (uint32_t event);
Nextern void USB_EndPoint15 (uint32_t event);
N
N/* USB Core Events Callback Functions */
Nextern void USB_Configure_Event (void);
Nextern void USB_Interface_Event (void);
Nextern void USB_Feature_Event   (void);
N
N
N#endif  /* __USBUSER_H__ */
L 33 "usbhw.c" 2
N
N
N#pragma diag_suppress 1441
N
N
N#define EP_MSK_CTRL 0x0001      /* Control Endpoint Logical Address Mask */
N#define EP_MSK_BULK 0xC924      /* Bulk Endpoint Logical Address Mask */
N#define EP_MSK_INT  0x4492      /* Interrupt Endpoint Logical Address Mask */
N#define EP_MSK_ISO  0x1248      /* Isochronous Endpoint Logical Address Mask */
N
N
N#if USB_DMA
X#if 1
N
N#pragma arm section zidata = "USB_RAM"
Nuint32_t UDCA[USB_EP_NUM];                     /* UDCA in USB RAM */
Xuint32_t UDCA[32];                      
N
Nuint32_t DD_NISO_Mem[4*DD_NISO_CNT];           /* Non-Iso DMA Descriptor Memory */
Xuint32_t DD_NISO_Mem[4*16];            
Nuint32_t DD_ISO_Mem [5*DD_ISO_CNT];            /* Iso DMA Descriptor Memory */
Xuint32_t DD_ISO_Mem [5*8];             
N#pragma arm section zidata
Nuint32_t udca[USB_EP_NUM];                     /* UDCA saved values */
Xuint32_t udca[32];                      
N
Nuint32_t DDMemMap[2];                          /* DMA Descriptor Memory Usage */
N
N#endif
N
N
N/*
N *  Get Endpoint Physical Address
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    Endpoint Physical Address
N */
N
Nuint32_t EPAdr (uint32_t EPNum) {
N  uint32_t val;
N
N  val = (EPNum & 0x0F) << 1;
N  if (EPNum & 0x80) {
N    val += 1;
N  }
N  return (val);
N}
N
N
N/*
N *  Write Command
N *    Parameters:      cmd:   Command
N *    Return Value:    None
N */
N
Nvoid WrCmd (uint32_t cmd) {
N
N  LPC_USB->DevIntClr = CCEMTY_INT;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000010;
N  LPC_USB->CmdCode = cmd;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->CmdCode = cmd;
N  while ((LPC_USB->DevIntSt & CCEMTY_INT) == 0);
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000010) == 0);
N}
N
N
N/*
N *  Write Command Data
N *    Parameters:      cmd:   Command
N *                     val:   Data
N *    Return Value:    None
N */
N
Nvoid WrCmdDat (uint32_t cmd, uint32_t val) {
N
N  LPC_USB->DevIntClr = CCEMTY_INT;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000010;
N  LPC_USB->CmdCode = cmd;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->CmdCode = cmd;
N  while ((LPC_USB->DevIntSt & CCEMTY_INT) == 0);
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000010) == 0);
N  LPC_USB->DevIntClr = CCEMTY_INT;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000010;
N  LPC_USB->CmdCode = val;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->CmdCode = val;
N  while ((LPC_USB->DevIntSt & CCEMTY_INT) == 0);
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000010) == 0);
N}
N
N
N/*
N *  Write Command to Endpoint
N *    Parameters:      cmd:   Command
N *                     val:   Data
N *    Return Value:    None
N */
N
Nvoid WrCmdEP (uint32_t EPNum, uint32_t cmd){
N
N  LPC_USB->DevIntClr = CCEMTY_INT;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000010;
N  LPC_USB->CmdCode = CMD_SEL_EP(EPAdr(EPNum));
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->CmdCode = (0x00000500 | ((EPAdr(EPNum)) << 16));
N  while ((LPC_USB->DevIntSt & CCEMTY_INT) == 0);
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000010) == 0);
N  LPC_USB->DevIntClr = CCEMTY_INT;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000010;
N  LPC_USB->CmdCode = cmd;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->CmdCode = cmd;
N  while ((LPC_USB->DevIntSt & CCEMTY_INT) == 0);
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000010) == 0);
N}
N
N
N/*
N *  Read Command Data
N *    Parameters:      cmd:   Command
N *    Return Value:    Data Value
N */
N
Nuint32_t RdCmdDat (uint32_t cmd) {
N
N  LPC_USB->DevIntClr = CCEMTY_INT | CDFULL_INT;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000010 | 0x00000020;
N  LPC_USB->CmdCode = cmd;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->CmdCode = cmd;
N  while ((LPC_USB->DevIntSt & CDFULL_INT) == 0);
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000020) == 0);
N  return (LPC_USB->CmdData);
X  return (((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->CmdData);
N}
N
N
N/*
N *  USB Initialize Function
N *   Called by the User to initialize USB
N *    Return Value:    None
N */
N
Nvoid USB_Init (void) {
N
N  LPC_PINCON->PINSEL1 &= ~((3<<26)|(3<<28));   /* P0.29 D+, P0.30 D- */
X  ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL1 &= ~((3<<26)|(3<<28));    
N  LPC_PINCON->PINSEL1 |=  ((1<<26)|(1<<28));   /* PINSEL1 26.27, 28.29  = 01 */
X  ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL1 |=  ((1<<26)|(1<<28));    
N
N  LPC_PINCON->PINSEL3 &= ~((3<< 4)|(3<<28));   /* P1.18 GoodLink, P1.30 VBUS */
X  ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL3 &= ~((3<< 4)|(3<<28));    
N  LPC_PINCON->PINSEL3 |=  ((1<< 4)|(2<<28));   /* PINSEL3 4.5 = 01, 28.29 = 10 */
X  ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL3 |=  ((1<< 4)|(2<<28));    
N
N  LPC_PINCON->PINSEL4 &= ~((3<<18)        );   /* P2.9 SoftConnect */
X  ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL4 &= ~((3<<18)        );    
N  LPC_PINCON->PINSEL4 |=  ((1<<18)        );   /* PINSEL4 18.19 = 01 */
X  ((LPC_PINCON_TypeDef *) ((0x40000000UL) + 0x2C000) )->PINSEL4 |=  ((1<<18)        );    
N
N  LPC_SC->PCONP |= (1UL<<31);                /* USB PCLK -> enable USB Per.       */
X  ((LPC_SC_TypeDef *) ((0x40080000UL) + 0x7C000) )->PCONP |= (1UL<<31);                 
N
N  LPC_USB->USBClkCtrl = 0x12;                /* Dev, AHB clock enable */
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->USBClkCtrl = 0x12;                 
N  while ((LPC_USB->USBClkSt & 0x12) != 0x12); 
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->USBClkSt & 0x12) != 0x12); 
N
N  NVIC_EnableIRQ(USB_IRQn);               /* enable USB interrupt */
N
N  USB_Reset();
N  USB_SetAddress(0);
N}
N
N
N/*
N *  USB Connect Function
N *   Called by the User to Connect/Disconnect USB
N *    Parameters:      con:   Connect/Disconnect
N *    Return Value:    None
N */
N
Nvoid USB_Connect (uint32_t con) {
N  WrCmdDat(CMD_SET_DEV_STAT, DAT_WR_BYTE(con ? DEV_CON : 0));
X  WrCmdDat(0x00FE0500, (0x00000100 | ((con ? 0x01 : 0) << 16)));
N}
N
N
N/*
N *  USB Reset Function
N *   Called automatically on USB Reset
N *    Return Value:    None
N */
N
Nvoid USB_Reset (void) {
N#if USB_DMA
X#if 1
N  uint32_t n;
N#endif
N
N  LPC_USB->EpInd = 0;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpInd = 0;
N  LPC_USB->MaxPSize = USB_MAX_PACKET0;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->MaxPSize = 64;
N  LPC_USB->EpInd = 1;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpInd = 1;
N  LPC_USB->MaxPSize = USB_MAX_PACKET0;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->MaxPSize = 64;
N  while ((LPC_USB->DevIntSt & EP_RLZED_INT) == 0);
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000100) == 0);
N
N  LPC_USB->EpIntClr  = 0xFFFFFFFF;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpIntClr  = 0xFFFFFFFF;
N  LPC_USB->EpIntEn   = 0xFFFFFFFF ^ USB_DMA_EP;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpIntEn   = 0xFFFFFFFF ^ 0x00000040;
N  LPC_USB->DevIntClr = 0xFFFFFFFF;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0xFFFFFFFF;
N  LPC_USB->DevIntEn  = DEV_STAT_INT    | EP_SLOW_INT    |
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntEn  = 0x00000008    | 0x00000004    |
N               (USB_SOF_EVENT   ? FRAME_INT : 0) |
X               (1   ? 0x00000001 : 0) |
N               (USB_ERROR_EVENT ? ERR_INT   : 0);
X               (0 ? 0x00000200   : 0);
N
N#if USB_DMA
X#if 1
N  LPC_USB->UDCAH   = USB_RAM_ADR;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->UDCAH   = 0x20080000;
N  LPC_USB->DMARClr = 0xFFFFFFFF;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DMARClr = 0xFFFFFFFF;
N  LPC_USB->EpDMADis  = 0xFFFFFFFF;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpDMADis  = 0xFFFFFFFF;
N  LPC_USB->EpDMAEn   = USB_DMA_EP;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpDMAEn   = 0x00000040;
N  LPC_USB->EoTIntClr = 0xFFFFFFFF;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EoTIntClr = 0xFFFFFFFF;
N  LPC_USB->NDDRIntClr = 0xFFFFFFFF;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->NDDRIntClr = 0xFFFFFFFF;
N  LPC_USB->SysErrIntClr = 0xFFFFFFFF;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->SysErrIntClr = 0xFFFFFFFF;
N  LPC_USB->DMAIntEn  = 0x00000007;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DMAIntEn  = 0x00000007;
N  DDMemMap[0] = 0x00000000;
N  DDMemMap[1] = 0x00000000;
N  for (n = 0; n < USB_EP_NUM; n++) {
X  for (n = 0; n < 32; n++) {
N    udca[n] = 0;
N    UDCA[n] = 0;
N  }
N#endif
N}
N
N
N/*
N *  USB Suspend Function
N *   Called automatically on USB Suspend
N *    Return Value:    None
N */
N
Nvoid USB_Suspend (void) {
N  /* Performed by Hardware */
N}
N
N
N/*
N *  USB Resume Function
N *   Called automatically on USB Resume
N *    Return Value:    None
N */
N
Nvoid USB_Resume (void) {
N  /* Performed by Hardware */
N}
N
N
N/*
N *  USB Remote Wakeup Function
N *   Called automatically on USB Remote Wakeup
N *    Return Value:    None
N */
N
Nvoid USB_WakeUp (void) {
N
N  if (USB_DeviceStatus & USB_GETSTATUS_REMOTE_WAKEUP) {
X  if (USB_DeviceStatus & 0x02) {
N    WrCmdDat(CMD_SET_DEV_STAT, DAT_WR_BYTE(DEV_CON));
X    WrCmdDat(0x00FE0500, (0x00000100 | ((0x01) << 16)));
N  }
N}
N
N
N/*
N *  USB Remote Wakeup Configuration Function
N *    Parameters:      cfg:   Enable/Disable
N *    Return Value:    None
N */
N
Nvoid USB_WakeUpCfg (uint32_t cfg) {
N  /* Not needed */
N}
N
N
N/*
N *  USB Set Address Function
N *    Parameters:      adr:   USB Address
N *    Return Value:    None
N */
N
Nvoid USB_SetAddress (uint32_t adr) {
N  WrCmdDat(CMD_SET_ADDR, DAT_WR_BYTE(DEV_EN | adr)); /* Don't wait for next */
X  WrCmdDat(0x00D00500, (0x00000100 | ((0x80 | adr) << 16)));  
N  WrCmdDat(CMD_SET_ADDR, DAT_WR_BYTE(DEV_EN | adr)); /*  Setup Status Phase */
X  WrCmdDat(0x00D00500, (0x00000100 | ((0x80 | adr) << 16)));  
N}
N
N
N/*
N *  USB Configure Function
N *    Parameters:      cfg:   Configure/Deconfigure
N *    Return Value:    None
N */
N
Nvoid USB_Configure (uint32_t cfg) {
N
N  WrCmdDat(CMD_CFG_DEV, DAT_WR_BYTE(cfg ? CONF_DVICE : 0));
X  WrCmdDat(0x00D80500, (0x00000100 | ((cfg ? 0x01 : 0) << 16)));
N
N  LPC_USB->ReEp = 0x00000003;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->ReEp = 0x00000003;
N  while ((LPC_USB->DevIntSt & EP_RLZED_INT) == 0);
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000100) == 0);
N  LPC_USB->DevIntClr = EP_RLZED_INT;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000100;
N}
N
N
N/*
N *  Configure USB Endpoint according to Descriptor
N *    Parameters:      pEPD:  Pointer to Endpoint Descriptor
N *    Return Value:    None
N */
N
Nvoid USB_ConfigEP (USB_ENDPOINT_DESCRIPTOR *pEPD) {
N  uint32_t num;
N
N  num = EPAdr(pEPD->bEndpointAddress);
N  LPC_USB->ReEp |= (1 << num);
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->ReEp |= (1 << num);
N  LPC_USB->EpInd = num;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpInd = num;
N  LPC_USB->MaxPSize = pEPD->wMaxPacketSize;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->MaxPSize = pEPD->wMaxPacketSize;
N  while ((LPC_USB->DevIntSt & EP_RLZED_INT) == 0);
X  while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000100) == 0);
N  LPC_USB->DevIntClr = EP_RLZED_INT;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000100;
N}
N
N
N/*
N *  Set Direction for USB Control Endpoint
N *    Parameters:      dir:   Out (dir == 0), In (dir <> 0)
N *    Return Value:    None
N */
N
Nvoid USB_DirCtrlEP (uint32_t dir) {
N  /* Not needed */
N}
N
N
N/*
N *  Enable USB Endpoint
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    None
N */
N
Nvoid USB_EnableEP (uint32_t EPNum) {
N  WrCmdDat(CMD_SET_EP_STAT(EPAdr(EPNum)), DAT_WR_BYTE(0));
X  WrCmdDat((0x00400500 | ((EPAdr(EPNum)) << 16)), (0x00000100 | ((0) << 16)));
N}
N
N
N/*
N *  Disable USB Endpoint
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    None
N */
N
Nvoid USB_DisableEP (uint32_t EPNum) {
N  WrCmdDat(CMD_SET_EP_STAT(EPAdr(EPNum)), DAT_WR_BYTE(EP_STAT_DA));
X  WrCmdDat((0x00400500 | ((EPAdr(EPNum)) << 16)), (0x00000100 | ((0x20) << 16)));
N}
N
N
N/*
N *  Reset USB Endpoint
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    None
N */
N
Nvoid USB_ResetEP (uint32_t EPNum) {
N  WrCmdDat(CMD_SET_EP_STAT(EPAdr(EPNum)), DAT_WR_BYTE(0));
X  WrCmdDat((0x00400500 | ((EPAdr(EPNum)) << 16)), (0x00000100 | ((0) << 16)));
N}
N
N
N/*
N *  Set Stall for USB Endpoint
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    None
N */
N
Nvoid USB_SetStallEP (uint32_t EPNum) {
N  WrCmdDat(CMD_SET_EP_STAT(EPAdr(EPNum)), DAT_WR_BYTE(EP_STAT_ST));
X  WrCmdDat((0x00400500 | ((EPAdr(EPNum)) << 16)), (0x00000100 | ((0x01) << 16)));
N}
N
N
N/*
N *  Clear Stall for USB Endpoint
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    None
N */
N
Nvoid USB_ClrStallEP (uint32_t EPNum) {
N  WrCmdDat(CMD_SET_EP_STAT(EPAdr(EPNum)), DAT_WR_BYTE(0));
X  WrCmdDat((0x00400500 | ((EPAdr(EPNum)) << 16)), (0x00000100 | ((0) << 16)));
N}
N
N
N/*
N *  Clear USB Endpoint Buffer
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    None
N */
N
Nvoid USB_ClearEPBuf (uint32_t EPNum) {
N  WrCmdEP(EPNum, CMD_CLR_BUF);
X  WrCmdEP(EPNum, 0x00F20500);
N}
N
N
N/*
N *  Read USB Endpoint Data
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *                     pData: Pointer to Data Buffer
N *    Return Value:    Number of bytes read
N */
N
Nuint32_t USB_ReadEP (uint32_t EPNum, uint8_t *pData) {
N  uint32_t cnt, n;
N
N  LPC_USB->Ctrl = ((EPNum & 0x0F) << 2) | CTRL_RD_EN;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->Ctrl = ((EPNum & 0x0F) << 2) | 0x00000001;
N
N  do {
N    cnt = LPC_USB->RxPLen;
X    cnt = ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->RxPLen;
N  } while ((cnt & PKT_RDY) == 0);
X  } while ((cnt & 0x00000800) == 0);
N  cnt &= PKT_LNGTH_MASK;
X  cnt &= 0x000003FF;
N
N  for (n = 0; n < (cnt + 3) / 4; n++) {
N    *((__packed uint32_t *)pData) = LPC_USB->RxData;
X    *((__packed uint32_t *)pData) = ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->RxData;
N    pData += 4;
N  }
N  LPC_USB->Ctrl = 0;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->Ctrl = 0;
N
N  if (((EP_MSK_ISO >> EPNum) & 1) == 0) {   /* Non-Isochronous Endpoint */
X  if (((0x1248 >> EPNum) & 1) == 0) {    
N    WrCmdEP(EPNum, CMD_CLR_BUF);
X    WrCmdEP(EPNum, 0x00F20500);
N  }
N  return (cnt);
N}
N
N
N/*
N *  Write USB Endpoint Data
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *                     pData: Pointer to Data Buffer
N *                     cnt:   Number of bytes to write
N *    Return Value:    Number of bytes written
N */
N
Nuint32_t USB_WriteEP (uint32_t EPNum, uint8_t *pData, uint32_t cnt) {
N  uint32_t n;
N
N  LPC_USB->Ctrl = ((EPNum & 0x0F) << 2) | CTRL_WR_EN;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->Ctrl = ((EPNum & 0x0F) << 2) | 0x00000002;
N
N  LPC_USB->TxPLen = cnt;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->TxPLen = cnt;
N
N  for (n = 0; n < (cnt + 3) / 4; n++) {
N    LPC_USB->TxData = *((__packed uint32_t *)pData);
X    ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->TxData = *((__packed uint32_t *)pData);
N    pData += 4;
N  }
N  LPC_USB->Ctrl = 0;
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->Ctrl = 0;
N  WrCmdEP(EPNum, CMD_VALID_BUF);
X  WrCmdEP(EPNum, 0x00FA0500);
N  return (cnt);
N}
N
N#if USB_DMA
X#if 1
N
N/* DMA Descriptor Memory Layout */
Nconst uint32_t DDAdr[2] = { DD_NISO_ADR, DD_ISO_ADR };
Xconst uint32_t DDAdr[2] = { (0x20080000 + 128), ((0x20080000 + 128) + (16 * 16)) };
Nconst uint32_t DDSz [2] = { 16,          20         };
N
N
N/*
N *  Setup USB DMA Transfer for selected Endpoint
N *    Parameters:      EPNum: Endpoint Number
N *                     pDD: Pointer to DMA Descriptor
N *    Return Value:    TRUE - Success, FALSE - Error
N */
N
Nuint32_t USB_DMA_Setup(uint32_t EPNum, USB_DMA_DESCRIPTOR *pDD) {
N  uint32_t num, ptr, nxt, iso, n;
N
N  iso = pDD->Cfg.Type.IsoEP;                /* Iso or Non-Iso Descriptor */
N  num = EPAdr(EPNum);                       /* Endpoint's Physical Address */
N
N  ptr = 0;                                  /* Current Descriptor */
N  nxt = udca[num];                          /* Initial Descriptor */
N  while (nxt) {                             /* Go through Descriptor List */
N    ptr = nxt;                              /* Current Descriptor */
N    if (!pDD->Cfg.Type.Link) {              /* Check for Linked Descriptors */
N      n = (ptr - DDAdr[iso]) / DDSz[iso];   /* Descriptor Index */
N      DDMemMap[iso] &= ~(1 << n);           /* Unmark Memory Usage */
N    }
N    nxt = *((uint32_t *)ptr);                  /* Next Descriptor */
N  }
N
N  for (n = 0; n < 32; n++) {                /* Search for available Memory */
N    if ((DDMemMap[iso] & (1 << n)) == 0) {
N      break;                                /* Memory found */
N    }
N  }
N  if (n == 32) return (FALSE);              /* Memory not available */
X  if (n == 32) return ((0));               
N
N  DDMemMap[iso] |= 1 << n;                  /* Mark Memory Usage */
N  nxt = DDAdr[iso] + n * DDSz[iso];         /* Next Descriptor */
N
N  if (ptr && pDD->Cfg.Type.Link) {
N    *((uint32_t *)(ptr + 0))  = nxt;           /* Link in new Descriptor */
N    *((uint32_t *)(ptr + 4)) |= 0x00000004;    /* Next DD is Valid */
N  } else {
N    udca[num] = nxt;                        /* Save new Descriptor */
N    UDCA[num] = nxt;                        /* Update UDCA in USB */
N  }
N
N  /* Fill in DMA Descriptor */
N  *(((uint32_t *)nxt)++) =  0;                 /* Next DD Pointer */
N  *(((uint32_t *)nxt)++) =  pDD->Cfg.Type.ATLE |
N                       (pDD->Cfg.Type.IsoEP << 4) |
N                       (pDD->MaxSize <<  5) |
N                       (pDD->BufLen  << 16);
N  *(((uint32_t *)nxt)++) =  pDD->BufAdr;
N  *(((uint32_t *)nxt)++) =  pDD->Cfg.Type.LenPos << 8;
N  if (iso) {
N    *((uint32_t *)nxt) =  pDD->InfoAdr;
N  }
N
N  return (TRUE); /* Success */
X  return ((1));  
N}
N
N
N/*
N *  Enable USB DMA Endpoint
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    None
N */
N
Nvoid USB_DMA_Enable (uint32_t EPNum) {
N  LPC_USB->EpDMAEn = 1 << EPAdr(EPNum);
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpDMAEn = 1 << EPAdr(EPNum);
N}
N
N
N/*
N *  Disable USB DMA Endpoint
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    None
N */
N
Nvoid USB_DMA_Disable (uint32_t EPNum) {
N  LPC_USB->EpDMADis = 1 << EPAdr(EPNum);
X  ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpDMADis = 1 << EPAdr(EPNum);
N}
N
N
N/*
N *  Get USB DMA Endpoint Status
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    DMA Status
N */
N
Nuint32_t USB_DMA_Status (uint32_t EPNum) {
N  uint32_t ptr, val;
N          
N  ptr = UDCA[EPAdr(EPNum)];                 /* Current Descriptor */
N  if (ptr == 0) 
N	return (USB_DMA_INVALID);
X	return (0x0000);
N
N  val = *((uint32_t *)(ptr + 3*4));            /* Status Information */
N  switch ((val >> 1) & 0x0F) {
N    case 0x00:                              /* Not serviced */
N      return (USB_DMA_IDLE);
X      return (0x0001);
N    case 0x01:                              /* Being serviced */
N      return (USB_DMA_BUSY);
X      return (0x0002);
N    case 0x02:                              /* Normal Completition */
N      return (USB_DMA_DONE);
X      return (0x0003);
N    case 0x03:                              /* Data Under Run */
N      return (USB_DMA_UNDER_RUN);
X      return (0x0005);
N    case 0x08:                              /* Data Over Run */
N      return (USB_DMA_OVER_RUN);
X      return (0x0004);
N    case 0x09:                              /* System Error */
N      return (USB_DMA_ERROR);
X      return (0x0006);
N  }
N
N  return (USB_DMA_UNKNOWN);
X  return (0xFFFF);
N}
N
N
N/*
N *  Get USB DMA Endpoint Current Buffer Address
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    DMA Address (or -1 when DMA is Invalid)
N */
N
Nuint32_t USB_DMA_BufAdr (uint32_t EPNum) {
N  uint32_t ptr, val;
N
N  ptr = UDCA[EPAdr(EPNum)];                 /* Current Descriptor */
N  if (ptr == 0)
N  {
N	return ((uint32_t)(-1));                /* DMA Invalid */
N  }
N
N  val = *((uint32_t *)(ptr + 2*4));         /* Buffer Address */
N  return (val);                             /* Current Address */
N}
N
N
N/*
N *  Get USB DMA Endpoint Current Buffer Count
N *   Number of transfered Bytes or Iso Packets
N *    Parameters:      EPNum: Endpoint Number
N *                       EPNum.0..3: Address
N *                       EPNum.7:    Dir
N *    Return Value:    DMA Count (or -1 when DMA is Invalid)
N */
N
Nuint32_t USB_DMA_BufCnt (uint32_t EPNum) {
N  uint32_t ptr, val;
N
N  ptr = UDCA[EPAdr(EPNum)];                 /* Current Descriptor */
N  if (ptr == 0)
N  { 
N	return ((uint32_t)(-1));                /* DMA Invalid */
N  }
N  val = *((uint32_t *)(ptr + 3*4));         /* Status Information */
N  return (val >> 16);                       /* Current Count */
N}
N
N
N#endif /* USB_DMA */
N
N
N/*
N *  Get USB Last Frame Number
N *    Parameters:      None
N *    Return Value:    Frame Number
N */
N
Nuint32_t USB_GetFrame (void) {
N  uint32_t val;
N
N  WrCmd(CMD_RD_FRAME);
X  WrCmd(0x00F50500);
N  val = RdCmdDat(DAT_RD_FRAME);
X  val = RdCmdDat(0x00F50200);
N  val = val | (RdCmdDat(DAT_RD_FRAME) << 8);
X  val = val | (RdCmdDat(0x00F50200) << 8);
N
N  return (val);
N}
N
N
N/*
N *  USB Interrupt Service Routine
N */
N
Nvoid USB_IRQHandler (void) {
N  uint32_t disr, val, n, m;
N  uint32_t episr, episrCur;
N
N  disr = LPC_USB->DevIntSt;       /* Device Interrupt Status */
X  disr = ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt;        
N
N  /* Device Status Interrupt (Reset, Connect change, Suspend/Resume) */
N  if (disr & DEV_STAT_INT) {
X  if (disr & 0x00000008) {
N    LPC_USB->DevIntClr = DEV_STAT_INT;
X    ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000008;
N    WrCmd(CMD_GET_DEV_STAT);
X    WrCmd(0x00FE0500);
N    val = RdCmdDat(DAT_GET_DEV_STAT);       /* Device Status */
X    val = RdCmdDat(0x00FE0200);        
N    if (val & DEV_RST) {                    /* Reset */
X    if (val & 0x10) {                     
N      USB_Reset();
N#if   USB_RESET_EVENT
X#if   1
N      USB_Reset_Event();
N#endif
N    }
N    if (val & DEV_CON_CH) {                 /* Connect change */
X    if (val & 0x02) {                  
N#if   USB_POWER_EVENT
X#if   0
S      USB_Power_Event(val & DEV_CON);
N#endif
N    }
N    if (val & DEV_SUS_CH) {                 /* Suspend/Resume */
X    if (val & 0x08) {                  
N      if (val & DEV_SUS) {                  /* Suspend */
X      if (val & 0x04) {                   
N        USB_Suspend();
N#if     USB_SUSPEND_EVENT
X#if     0
S        USB_Suspend_Event();
N#endif
N      } else {                              /* Resume */
N        USB_Resume();
N#if     USB_RESUME_EVENT
X#if     0
S        USB_Resume_Event();
N#endif
N      }
N    }
N    goto isr_end;
N  }
N
N#if USB_SOF_EVENT
X#if 1
N  /* Start of Frame Interrupt */
N  if (disr & FRAME_INT) {
X  if (disr & 0x00000001) {
N    USB_SOF_Event();
N  }
N#endif
N
N#if USB_ERROR_EVENT
X#if 0
S  /* Error Interrupt */
S  if (disr & ERR_INT) {
S    WrCmd(CMD_RD_ERR_STAT);
S    val = RdCmdDat(DAT_RD_ERR_STAT);
S    USB_Error_Event(val);
S  }
N#endif
N
N  /* Endpoint's Slow Interrupt */
N  if (disr & EP_SLOW_INT) {
X  if (disr & 0x00000004) {
N    episrCur = 0;
N    episr    = LPC_USB->EpIntSt;
X    episr    = ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpIntSt;
N    for (n = 0; n < USB_EP_NUM; n++) {      /* Check All Endpoints */
X    for (n = 0; n < 32; n++) {       
N      if (episr == episrCur) break;         /* break if all EP interrupts handled */
N      if (episr & (1 << n)) {
N        episrCur |= (1 << n);
N        m = n >> 1;
N  
N        LPC_USB->EpIntClr = (1 << n);
X        ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EpIntClr = (1 << n);
N        while ((LPC_USB->DevIntSt & CDFULL_INT) == 0);
X        while ((((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntSt & 0x00000020) == 0);
N        val = LPC_USB->CmdData;
X        val = ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->CmdData;
N  
N        if ((n & 1) == 0) {                 /* OUT Endpoint */
N          if (n == 0) {                     /* Control OUT Endpoint */
N            if (val & EP_SEL_STP) {         /* Setup Packet */
X            if (val & 0x04) {          
N              if (USB_P_EP[0]) {
N                USB_P_EP[0](USB_EVT_SETUP);
X                USB_P_EP[0](1);
N                continue;
N              }
N            }
N          }
N          if (USB_P_EP[m]) {
N            USB_P_EP[m](USB_EVT_OUT);
X            USB_P_EP[m](2);
N          }
N        } else {                            /* IN Endpoint */
N          if (USB_P_EP[m]) {
N            USB_P_EP[m](USB_EVT_IN);
X            USB_P_EP[m](3);
N          }
N        }
N      }
N    }
N    LPC_USB->DevIntClr = EP_SLOW_INT;
X    ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DevIntClr = 0x00000004;
N  }
N
N#if USB_DMA
X#if 1
N
N  if (LPC_USB->DMAIntSt & 0x00000001) {          /* End of Transfer Interrupt */
X  if (((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DMAIntSt & 0x00000001) {           
N    val = LPC_USB->EoTIntSt;
X    val = ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EoTIntSt;
N    for (n = 2; n < USB_EP_NUM; n++) {      /* Check All Endpoints */
X    for (n = 2; n < 32; n++) {       
N      if (val & (1 << n)) {
N        m = n >> 1;
N        if ((n & 1) == 0) {                 /* OUT Endpoint */
N          if (USB_P_EP[m]) {
N            USB_P_EP[m](USB_EVT_OUT_DMA_EOT);
X            USB_P_EP[m](8);
N          }
N        } else {                            /* IN Endpoint */
N          if (USB_P_EP[m]) {
N            USB_P_EP[m](USB_EVT_IN_DMA_EOT);
X            USB_P_EP[m](9);
N          }
N        }
N      }
N    }
N    LPC_USB->EoTIntClr = val;
X    ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->EoTIntClr = val;
N  }
N
N  if (LPC_USB->DMAIntSt & 0x00000002) {          /* New DD Request Interrupt */
X  if (((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DMAIntSt & 0x00000002) {           
N    val = LPC_USB->NDDRIntSt;
X    val = ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->NDDRIntSt;
N    for (n = 2; n < USB_EP_NUM; n++) {      /* Check All Endpoints */
X    for (n = 2; n < 32; n++) {       
N      if (val & (1 << n)) {
N        m = n >> 1;
N        if ((n & 1) == 0) {                 /* OUT Endpoint */
N          if (USB_P_EP[m]) {
N            USB_P_EP[m](USB_EVT_OUT_DMA_NDR);
X            USB_P_EP[m](10);
N          }
N        } else {                            /* IN Endpoint */
N          if (USB_P_EP[m]) {
N            USB_P_EP[m](USB_EVT_IN_DMA_NDR);
X            USB_P_EP[m](11);
N          }
N        }
N      }
N    }
N    LPC_USB->NDDRIntClr = val;
X    ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->NDDRIntClr = val;
N  }
N
N  if (LPC_USB->DMAIntSt & 0x00000004) {          /* System Error Interrupt */
X  if (((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->DMAIntSt & 0x00000004) {           
N    val = LPC_USB->SysErrIntSt;
X    val = ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->SysErrIntSt;
N    for (n = 2; n < USB_EP_NUM; n++) {      /* Check All Endpoints */
X    for (n = 2; n < 32; n++) {       
N      if (val & (1 << n)) {
N        m = n >> 1;
N        if ((n & 1) == 0) {                 /* OUT Endpoint */
N          if (USB_P_EP[m]) {
N            USB_P_EP[m](USB_EVT_OUT_DMA_ERR);
X            USB_P_EP[m](12);
N          }
N        } else {                            /* IN Endpoint */
N          if (USB_P_EP[m]) {
N            USB_P_EP[m](USB_EVT_IN_DMA_ERR);
X            USB_P_EP[m](13);
N          }
N        }
N      }
N    }
N    LPC_USB->SysErrIntClr = val;
X    ((LPC_USB_TypeDef *) ((0x50000000UL) + 0x0C000) )->SysErrIntClr = val;
N  }
N
N#endif /* USB_DMA */
N
Nisr_end:
N  return;
N}
